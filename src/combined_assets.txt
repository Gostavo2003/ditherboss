
============================================================
FILE: ./App.css
============================================================

#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



============================================================
FILE: ./App.tsx
============================================================


import Sidebar from './components/Sidebar';
import Workspace from './components/Workspace';
import AdvancedPanel from './components/AdvancedPanel';
import { BatchModal } from './components/BatchModal';

function App() {
  return (
    <div className="flex w-full h-screen bg-gray-950 text-gray-100 font-sans overflow-hidden">
      {/* Sidebar Controls */}
      <Sidebar />

      {/* Main Workspace */}
      <Workspace />

      {/* Advanced Panel */}
      <AdvancedPanel />

      {/* Modals */}
      <BatchModal />
    </div>
  );
}

export default App;



============================================================
FILE: ./components\AdvancedPanel.tsx
============================================================

import React, { useMemo } from 'react';
import { useSettings } from '../context/SettingsContext';
import { Settings2, X, Brush, Droplets } from 'lucide-react';

const AdvancedPanel: React.FC = () => {
    const { settings, updateSettings } = useSettings();

    // Sort valid colors by count descending
    const sortedPalette = useMemo(() => {
        return [...settings.colorPalette].sort((a, b) => {
            const countA = settings.pixelCounts[a.hex] || 0;
            const countB = settings.pixelCounts[b.hex] || 0;
            return countB - countA;
        });
    }, [settings.colorPalette, settings.pixelCounts]);

    if (!settings.isAdvancedPanelOpen) return null;

    return (
        <div className="w-80 bg-gray-950 border-l border-gray-800 flex flex-col h-full overflow-y-auto custom-scrollbar select-none z-40 transition-all duration-300">
            <div className="p-4 border-b border-gray-800 flex items-center justify-between sticky top-0 bg-gray-950 z-10">
                <div className="flex items-center gap-2 text-indigo-400">
                    <Settings2 className="w-5 h-5" />
                    <h2 className="font-semibold tracking-wider text-sm">ADVANCED SYSTEM</h2>
                </div>
                <button
                    onClick={() => updateSettings({ isAdvancedPanelOpen: false })}
                    className="text-gray-500 hover:text-white transition-colors"
                >
                    <X className="w-5 h-5" />
                </button>
            </div>

            <div className="p-4 space-y-8">
                {/* Paint Tools Section */}
                <div className="space-y-4">
                    <div className="flex items-center gap-2 mb-2 text-gray-300">
                        <Brush className="w-4 h-4" />
                        <h3 className="text-xs font-bold uppercase tracking-widest">Smart Paint Engine</h3>
                    </div>

                    <div className="space-y-3">
                        <div className="flex justify-between items-center">
                            <label className="text-xs font-medium text-gray-400">Brush Preset</label>
                            <select
                                value={settings.brushPreset}
                                onChange={(e) => updateSettings({ brushPreset: e.target.value as any })}
                                className="bg-gray-900 border border-gray-700 text-gray-200 text-xs rounded-md px-2 py-1 focus:outline-none focus:border-indigo-500"
                            >
                                <option value="solid">Solid Edge</option>
                                <option value="dither">Dither Fade</option>
                                <option value="noise">Noise Blend</option>
                            </select>
                        </div>

                        <div>
                            <div className="flex justify-between text-xs mb-1">
                                <span className="text-gray-400">Brush Size</span>
                                <span className="text-gray-300">{settings.brushSize}px</span>
                            </div>
                            <input
                                type="range"
                                min={1}
                                max={50}
                                value={settings.brushSize}
                                onChange={(e) => updateSettings({ brushSize: Number(e.target.value) })}
                                className="w-full accent-indigo-500"
                            />
                        </div>

                        <div>
                            <div className="flex justify-between text-xs mb-1">
                                <span className="text-gray-400">Hardness</span>
                                <span className="text-gray-300">{settings.brushHardness}%</span>
                            </div>
                            <input
                                type="range"
                                min={0}
                                max={100}
                                value={settings.brushHardness}
                                onChange={(e) => updateSettings({ brushHardness: Number(e.target.value) })}
                                className="w-full accent-indigo-500"
                            />
                        </div>

                        <div className="pt-2">
                            <label className="text-xs font-medium text-gray-400 mb-2 block">Active Paint Color</label>
                            <div className="flex items-center gap-2">
                                <input
                                    type="color"
                                    value={settings.activePaintColor || '#ff0000'}
                                    onChange={(e) => updateSettings({ activePaintColor: e.target.value })}
                                    className="w-8 h-8 rounded cursor-pointer border-0 p-0 bg-transparent"
                                />
                                <span className="text-xs text-gray-400 font-monouppercase mx-2 uppercase">
                                    {settings.activePaintColor || 'NONE'}
                                </span>
                                <button
                                    onClick={() => updateSettings({ activePaintColor: null })}
                                    className="text-[10px] px-2 py-1 bg-gray-800 hover:bg-gray-700 text-gray-300 rounded border border-gray-700 transition-colors"
                                >
                                    CLEAR
                                </button>
                            </div>
                        </div>

                    </div>
                </div>

                <hr className="border-gray-800" />

                {/* Palette Insights Section */}
                <div className="space-y-4">
                    <div className="flex items-center gap-2 mb-2 text-gray-300">
                        <Droplets className="w-4 h-4" />
                        <h3 className="text-xs font-bold uppercase tracking-widest">Palette & Insights</h3>
                    </div>

                    <p className="text-[10px] text-gray-500 leading-tight mb-3">
                        Hover over colors to mask the image and see where they are distributed. Click to set as active paint color.
                    </p>

                    <div className="space-y-2">
                        {sortedPalette.map((color) => {
                            const count = settings.pixelCounts[color.hex] || 0;
                            const isActive = settings.activePaintColor === color.hex;

                            return (
                                <div
                                    key={color.id}
                                    onMouseEnter={() => updateSettings({ hoveredColor: color.hex })}
                                    onMouseLeave={() => updateSettings({ hoveredColor: null })}
                                    onClick={() => updateSettings({ activePaintColor: color.hex })}
                                    className={`flex items-center justify-between p-2 rounded-lg cursor-pointer transition-colors border ${isActive ? 'bg-indigo-900/30 border-indigo-500/50' : 'bg-gray-900 border-gray-800 hover:border-gray-600'}`}
                                >
                                    <div className="flex items-center gap-3">
                                        <div
                                            className="w-6 h-6 rounded shadow-sm border border-black/20"
                                            style={{ backgroundColor: color.hex }}
                                        />
                                        <span className="text-xs font-mono text-gray-300 uppercase">{color.hex}</span>
                                    </div>
                                    <span className="text-[10px] bg-gray-950 px-2 py-1 rounded text-gray-400 font-mono">
                                        {count.toLocaleString()} px
                                    </span>
                                </div>
                            );
                        })}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default AdvancedPanel;



============================================================
FILE: ./components\BatchModal.tsx
============================================================

import React, { useState, useEffect, useRef } from 'react';
import { useSettings } from '../context/SettingsContext';
import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import { v4 as uuidv4 } from 'uuid';
import type { ProcessPayload, WorkerMessage, WorkerResponse } from '../worker/imageWorker';


export const BatchModal: React.FC = () => {
    const { settings } = useSettings();
    const [isOpen, setIsOpen] = useState(false);
    const [isProcessing, setIsProcessing] = useState(false);
    const [progress, setProgress] = useState({ current: 0, total: 0 });
    const [statusText, setStatusText] = useState('');
    const [exportFormat, setExportFormat] = useState<'png' | 'jpeg' | 'svg'>('png');

    const workerRef = useRef<Worker | null>(null);

    useEffect(() => {
        const handleOpen = () => setIsOpen(true);
        window.addEventListener('OPEN_BATCH', handleOpen);
        return () => window.removeEventListener('OPEN_BATCH', handleOpen);
    }, []);

    useEffect(() => {
        if (isOpen && !workerRef.current) {
            workerRef.current = new Worker(new URL('../worker/imageWorker.ts', import.meta.url), { type: 'module' });
        }
        return () => {
            if (workerRef.current && !isProcessing) {
                workerRef.current.terminate();
                workerRef.current = null;
            }
        };
    }, [isOpen, isProcessing]);

    const handleClose = () => {
        if (!isProcessing) setIsOpen(false);
    };

    const processFiles = async (files: FileList | File[]) => {
        setIsProcessing(true);
        setStatusText('Reading files...');

        let imagesToProcess: { name: string, blob: Blob }[] = [];

        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            if (file.name.endsWith('.zip')) {
                setStatusText(`Extracting ${file.name}...`);
                const zip = await JSZip.loadAsync(file);
                for (const [filename, zipEntry] of Object.entries(zip.files)) {
                    if (!zipEntry.dir && filename.match(/\.(jpe?g|png|webp|gif)$/i)) {
                        const blob = await zipEntry.async("blob");
                        imagesToProcess.push({ name: filename, blob });
                    }
                }
            } else if (file.type.startsWith('image/')) {
                imagesToProcess.push({ name: file.name, blob: file });
            }
        }

        if (imagesToProcess.length === 0) {
            setStatusText('No images found.');
            setIsProcessing(false);
            return;
        }

        setProgress({ current: 0, total: imagesToProcess.length });

        const resultZip = new JSZip();

        for (let i = 0; i < imagesToProcess.length; i++) {
            const { name, blob } = imagesToProcess[i];
            setStatusText(`Processing ${name}... (${i + 1}/${imagesToProcess.length})`);

            try {
                const processedBlob = await processSingleImage(blob);

                // Determine new extension
                let newExt = exportFormat === 'jpeg' ? 'jpg' : exportFormat;
                let newName = name.replace(/\.[^/.]+$/, "") + `_dithered.${newExt}`;

                resultZip.file(newName, processedBlob);
            } catch (err) {
                console.error(`Error processing ${name}:`, err);
            }

            setProgress(prev => ({ ...prev, current: i + 1 }));
        }

        setStatusText('Generating final ZIP file...');
        const content = await resultZip.generateAsync({ type: 'blob' });
        saveAs(content, `ditherboss_batch_${Date.now()}.zip`);

        setStatusText('Done!');
        setIsProcessing(false);
        setTimeout(() => setIsOpen(false), 2000);
    };

    const processSingleImage = (blob: Blob): Promise<Blob> => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const url = URL.createObjectURL(blob);
            img.onload = () => {
                URL.revokeObjectURL(url);
                let targetWidth = Math.min(settings.width, img.width);
                let targetHeight = Math.round(img.height * (targetWidth / img.width));

                const canvas = document.createElement('canvas');
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                if (!ctx) return reject('No ctx');

                if (settings.colorBlur > 0) ctx.filter = `blur(${settings.colorBlur}px)`;
                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
                ctx.filter = 'none';

                const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
                const jobId = uuidv4();

                const listener = (e: MessageEvent<WorkerResponse>) => {
                    if (e.data.id === jobId) {
                        workerRef.current?.removeEventListener('message', listener);
                        if (e.data.type === 'RESULT' && e.data.imageData) {

                            // Draw back to canvas
                            ctx.putImageData(e.data.imageData, 0, 0);

                            // Handle Export Format
                            if (exportFormat === 'svg') {
                                // Since we need a Blob, we must mock the internal exportSVG saveAs call
                                // Or better, just grab the dataURL and use JSZip's base64 support.
                                // It's complex, so for batch, let's keep raster, or adapt exportSVG.
                                // For now, let's use canvas.toBlob for raster.
                                canvas.toBlob(b => {
                                    if (b) resolve(b); else reject();
                                }, 'image/png');
                                // (Implementation limitation for this iteration: SVG trace doesn't easily return Blob out of the box in the util without modification. Let's force raster for batch or adapt it later).
                            } else {
                                const mime = exportFormat === 'jpeg' ? 'image/jpeg' : 'image/png';
                                canvas.toBlob(b => {
                                    if (b) resolve(b); else reject();
                                }, mime, 1.0);
                                // Note: DPI injection omitted in batch for brevity, could be added via dataURL conversion.
                            }

                        } else {
                            reject(e.data.error);
                        }
                    }
                };

                workerRef.current?.addEventListener('message', listener);

                const payload: ProcessPayload = {
                    imageData, mode: settings.mode, width: targetWidth,
                    bwThreshold: settings.bwThreshold, bwMethod: settings.bwMethod, bwFactor: settings.bwFactor, bwStretch: settings.bwStretch,
                    colorBlur: settings.colorBlur, colorExtractMethod: settings.colorExtractMethod, colorPaletteMode: settings.colorPaletteMode, colorPalette: settings.colorPalette,
                    colorCount: settings.colorCount
                };

                workerRef.current?.postMessage({ type: 'PROCESS_IMAGE', payload, id: jobId } as WorkerMessage, [imageData.data.buffer]);
            };
            img.onerror = () => { URL.revokeObjectURL(url); reject('Load error'); };
            img.src = url;
        });
    };

    const handleDrop = (e: React.DragEvent) => {
        e.preventDefault();
        if (isProcessing) return;
        if (e.dataTransfer.files) processFiles(e.dataTransfer.files);
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
            <div className="bg-gray-900 border border-gray-800 rounded-xl shadow-2xl w-full max-w-2xl overflow-hidden flex flex-col">
                <div className="px-6 py-4 border-b border-gray-800 flex items-center justify-between">
                    <h2 className="text-xl font-bold tracking-tight text-white">Batch Processor</h2>
                    {!isProcessing && (
                        <button onClick={handleClose} className="text-gray-400 hover:text-white transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6L6 18M6 6L18 18" /></svg>
                        </button>
                    )}
                </div>

                <div className="p-8 flex flex-col items-center">

                    {!isProcessing ? (
                        <>
                            <div className="w-full flex justify-center mb-6 gap-4">
                                <label className="text-sm font-semibold text-gray-400">Export Format:</label>
                                <select
                                    value={exportFormat} onChange={e => setExportFormat(e.target.value as any)}
                                    className="bg-gray-950 border border-gray-700 rounded px-2 py-0.5 text-sm text-white"
                                >
                                    <option value="png">PNG (Raster)</option>
                                    <option value="jpeg">JPEG (Raster)</option>
                                </select>
                            </div>

                            <label
                                onDragOver={e => e.preventDefault()}
                                onDrop={handleDrop}
                                className="w-full max-w-md h-64 border-2 border-dashed border-gray-700 hover:border-indigo-500 rounded-xl flex flex-col items-center justify-center cursor-pointer transition-colors bg-gray-950/50"
                            >
                                <svg className="w-12 h-12 text-gray-500 mb-4" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" x2="12" y1="3" y2="15" /></svg>
                                <p className="text-lg font-medium text-gray-300">Drop Images or ZIP file</p>
                                <p className="text-sm text-gray-500 mt-2">or click to browse</p>
                                <input type="file" multiple accept="image/*,.zip" className="hidden" onChange={e => e.target.files && processFiles(e.target.files)} />
                            </label>
                        </>
                    ) : (
                        <div className="w-full max-w-md flex flex-col items-center py-12">
                            <div className="text-indigo-400 mb-4 animate-pulse">
                                <svg className="w-12 h-12 animate-spin" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="4.93" x2="19.07" y2="7.76"></line></svg>
                            </div>
                            <p className="text-lg font-medium text-white mb-2">{statusText}</p>
                            <div className="w-full bg-gray-800 rounded-full h-3 mb-2 overflow-hidden border border-gray-700">
                                <div
                                    className="bg-indigo-500 h-3 rounded-full transition-all duration-200 shadow-[0_0_10px_rgba(99,102,241,0.5)]"
                                    style={{ width: `${progress.total ? (progress.current / progress.total) * 100 : 0}%` }}
                                />
                            </div>
                            <p className="text-sm font-mono text-gray-500">{progress.current} / {progress.total}</p>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};



============================================================
FILE: ./components\BlackWhiteControls.tsx
============================================================

import React from 'react';
import { useSettings } from '../context/SettingsContext';

const BlackWhiteControls: React.FC = () => {
    const { settings, updateSettings } = useSettings();

    const isDithered = ['floyd', 'atkinson', 'jarvis', 'stucki', 'random', 'bluenoise', 'bayer2', 'bayer4', 'bayer8', 'clustered4'].includes(settings.bwMethod);

    return (
        <div className="space-y-6 animate-in fade-in zoom-in-95 duration-200">

            {/* Threshold Slider */}
            <div className="space-y-3">
                <label className="text-xs font-bold text-gray-500 tracking-widest uppercase flex justify-between">
                    <span>Threshold</span>
                    <span className="text-gray-300">{settings.bwThreshold}</span>
                </label>
                <input
                    type="range"
                    min="1"
                    max="255"
                    value={settings.bwThreshold}
                    onChange={(e) => updateSettings({ bwThreshold: parseInt(e.target.value) })}
                    className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                />
            </div>

            {/* Dithering Method */}
            <div className="space-y-3">
                <label className="text-xs font-bold text-gray-500 tracking-widest uppercase">
                    Dithering Method
                </label>
                <select
                    value={settings.bwMethod}
                    onChange={(e) => updateSettings({ bwMethod: e.target.value })}
                    className="w-full bg-gray-900 border border-gray-800 text-gray-200 text-sm rounded-lg focus:ring-gray-500 focus:border-gray-500 block p-2.5 outline-none hover:border-gray-700 transition-colors cursor-pointer appearance-none"
                >
                    <option value="bitmap">Bitmap (No Dither)</option>
                    <option value="floyd">Floyd-Steinberg</option>
                    <option value="atkinson">Atkinson</option>
                    <option value="jarvis">Jarvis-Judice-Ninke</option>
                    <option value="stucki">Stucki</option>
                    <option value="bayer2">Bayer 2x2</option>
                    <option value="bayer4">Bayer 4x4</option>
                    <option value="bayer8">Bayer 8x8</option>
                    <option value="clustered4">Clustered 4x4</option>
                    <option value="stretch">Stretch</option>
                    <option value="random">Random</option>
                    <option value="bluenoise">Blue Noise</option>
                </select>
            </div>

            {/* Dither Intensity Slider */}
            {isDithered && (
                <div className="space-y-3">
                    <label className="text-xs font-bold text-gray-500 tracking-widest uppercase flex justify-between">
                        <span>Dither Intensity</span>
                        <span className="text-gray-300">{settings.bwFactor.toFixed(2)}</span>
                    </label>
                    <input
                        type="range"
                        min="0.1"
                        max="2.0"
                        step="0.01"
                        value={settings.bwFactor}
                        onChange={(e) => updateSettings({ bwFactor: parseFloat(e.target.value) })}
                        className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                    />
                </div>
            )}

            {/* Stretch Slider */}
            {settings.bwMethod === 'stretch' && (
                <div className="space-y-3">
                    <label className="text-xs font-bold text-gray-500 tracking-widest uppercase flex justify-between">
                        <span>Stretch</span>
                        <span className="text-gray-300">{settings.bwStretch}</span>
                    </label>
                    <input
                        type="range"
                        min="-100"
                        max="100"
                        step="1"
                        value={settings.bwStretch}
                        onChange={(e) => updateSettings({ bwStretch: parseInt(e.target.value) })}
                        className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                    />
                </div>
            )}

        </div>
    );
};

export default BlackWhiteControls;



============================================================
FILE: ./components\ColorControls.tsx
============================================================

import React from 'react';
import PaletteEditor from './PaletteEditor';
import { useSettings } from '../context/SettingsContext';

const ColorControls: React.FC = () => {
    const { settings, updateSettings } = useSettings();

    return (
        <div className="space-y-8 animate-in fade-in zoom-in-95 duration-200">

            {/* Blur Input Option */}
            <div className="space-y-3">
                <label className="text-xs font-bold text-gray-500 tracking-widest uppercase flex justify-between">
                    <span>Pre-Process Blur</span>
                    <span className="text-gray-300">{settings.colorBlur.toFixed(1)}px</span>
                </label>
                <input
                    type="range"
                    min="0"
                    max="10"
                    step="0.1"
                    value={settings.colorBlur}
                    onChange={(e) => updateSettings({ colorBlur: parseFloat(e.target.value) })}
                    className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                />
                <p className="text-[10px] text-gray-600 leading-tight">
                    Apply a slight blur before color extraction to reduce noise and create smoother gradients.
                </p>
            </div>

            <div className="space-y-6">
                {/* Dithering Method */}
                <div className="space-y-3">
                    <label className="text-xs font-bold text-gray-500 tracking-widest uppercase">
                        Dithering Method
                    </label>
                    <select
                        value={settings.bwMethod}
                        onChange={(e) => updateSettings({ bwMethod: e.target.value })}
                        className="w-full bg-gray-900 border border-gray-800 text-gray-200 text-sm rounded-lg focus:ring-gray-500 focus:border-gray-500 block p-2.5 outline-none hover:border-gray-700 transition-colors cursor-pointer appearance-none"
                    >
                        <option value="bitmap">Bitmap (No Dither)</option>
                        <option value="floyd">Floyd-Steinberg</option>
                        <option value="atkinson">Atkinson</option>
                        <option value="jarvis">Jarvis-Judice-Ninke</option>
                        <option value="stucki">Stucki</option>
                        <option value="bayer2">Bayer 2x2</option>
                        <option value="bayer4">Bayer 4x4</option>
                        <option value="bayer8">Bayer 8x8</option>
                        <option value="clustered4">Clustered 4x4</option>
                        <option value="stretch">Stretch</option>
                        <option value="random">Random</option>
                        <option value="bluenoise">Blue Noise</option>
                    </select>
                </div>

                {/* Error Factor Slider */}
                {['floyd', 'atkinson', 'jarvis', 'stucki', 'random', 'bluenoise', 'bayer2', 'bayer4', 'bayer8', 'clustered4'].includes(settings.bwMethod) && (
                    <div className="space-y-3">
                        <label className="text-xs font-bold text-gray-500 tracking-widest uppercase flex justify-between">
                            <span>Dither Intensity</span>
                            <span className="text-gray-300">{settings.bwFactor.toFixed(2)}</span>
                        </label>
                        <input
                            type="range"
                            min="0.1"
                            max="2.0"
                            step="0.01"
                            value={settings.bwFactor}
                            onChange={(e) => updateSettings({ bwFactor: parseFloat(e.target.value) })}
                            className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                        />
                    </div>
                )}

                {/* Stretch Slider */}
                {settings.bwMethod === 'stretch' && (
                    <div className="space-y-3">
                        <label className="text-xs font-bold text-gray-500 tracking-widest uppercase flex justify-between">
                            <span>Stretch</span>
                            <span className="text-gray-300">{settings.bwStretch}%</span>
                        </label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            step="1"
                            value={settings.bwStretch}
                            onChange={(e) => updateSettings({ bwStretch: parseInt(e.target.value) })}
                            className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                        />
                    </div>
                )}
            </div>

            <div className="h-px bg-gray-800 w-full" />

            {/* Palette Tools */}
            <div className="space-y-5">
                <div className="flex items-center justify-between">
                    <label className="text-xs font-bold text-gray-400 tracking-widest uppercase flex items-center gap-2">
                        Color Palette
                    </label>
                    <button className="text-xs font-bold text-gray-400 hover:text-white bg-gray-900 border border-gray-800 px-2 py-1 rounded transition-colors">
                        PRESETS
                    </button>
                </div>

                {/* Extraction Mode */}
                <div className="space-y-3">
                    <span className="text-[10px] text-gray-400 uppercase font-semibold block mb-1">Extraction Method</span>
                    <select
                        value={settings.colorExtractMethod}
                        onChange={(e) => updateSettings({ colorExtractMethod: e.target.value })}
                        className="w-full bg-gray-900 border border-gray-800 text-gray-200 text-sm rounded-lg focus:ring-gray-500 focus:border-gray-500 block p-2 outline-none hover:border-gray-700 transition-colors cursor-pointer appearance-none"
                    >
                        <option value="kmeans">K-Means Clustering</option>
                        <option value="histogram">Histogram / Frequency</option>
                        <option value="mediancut">Median Cut</option>
                        <option value="hue">Hue Clustering</option>
                        <option value="extreme">Extreme Colors</option>
                        <option value="pronounced">Pronounced</option>
                        <option value="varied">Varied Hues</option>
                        <option value="distant">Distant (LAB)</option>
                        <option value="contrasting">High Contrast</option>
                    </select>
                </div>

                {/* Color Count Slider */}
                <div className="space-y-3">
                    <label className="text-xs font-bold text-gray-400 tracking-widest uppercase flex justify-between">
                        <span>Palette Size</span>
                        <span className="text-gray-300">{settings.colorCount} Colors</span>
                    </label>
                    <input
                        type="range"
                        min="2"
                        max="32"
                        step="1"
                        value={settings.colorCount}
                        onChange={(e) => updateSettings({ colorCount: parseInt(e.target.value) })}
                        className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                    />
                </div>

                {/* The Palette Editor Integration */}
                <PaletteEditor
                    colors={settings.colorPalette}
                    setColors={(newPalette) => updateSettings({ colorPalette: newPalette })}
                />
            </div>

        </div>
    );
};

export default ColorControls;



============================================================
FILE: ./components\GlobalControls.tsx
============================================================

import React from 'react';
import { useSettings } from '../context/SettingsContext';

const GlobalControls: React.FC = () => {
    const { settings, updateSettings } = useSettings();

    return (
        <div className="space-y-6 animate-in fade-in zoom-in-95 duration-200">

            {/* Resolution Slider */}
            <div className="space-y-3">
                <label className="text-xs font-bold text-gray-500 tracking-widest uppercase flex justify-between">
                    <span>Resolution (Width)</span>
                    <span className="text-gray-300">{settings.width}px</span>
                </label>
                <input
                    type="range"
                    min="10"
                    max="3000"
                    value={settings.width}
                    onChange={(e) => updateSettings({ width: parseInt(e.target.value) })}
                    className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                />
                <div className="flex justify-between text-[10px] text-gray-600 font-medium">
                    <span>Faster (10px)</span>
                    <span>Original</span>
                </div>
            </div>

            {/* Pixel Scale Slider */}
            <div className="space-y-3">
                <label className="text-xs font-bold text-gray-500 tracking-widest uppercase flex justify-between">
                    <span>Pixel Size</span>
                    <span className="text-gray-300">{settings.ditherScale}x</span>
                </label>
                <input
                    type="range"
                    min="1"
                    max="8"
                    step="1"
                    value={settings.ditherScale}
                    onChange={(e) => updateSettings({ ditherScale: parseInt(e.target.value) })}
                    className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                />
            </div>

        </div>
    );
};

export default GlobalControls;



============================================================
FILE: ./components\PaletteEditor.tsx
============================================================

import React, { useState } from 'react';
import { HexColorPicker } from 'react-colorful';
import { v4 as uuidv4 } from 'uuid';
import { Plus, X, PaintBucket } from 'lucide-react';
import { useSettings } from '../context/SettingsContext';

export interface PaletteColor {
    id: string;
    hex: string;
    threshold: number; // 0 to 1
}

interface PaletteEditorProps {
    colors: PaletteColor[];
    setColors: (colors: PaletteColor[]) => void;
}

const PaletteEditor: React.FC<PaletteEditorProps> = ({ colors, setColors }) => {
    const { updateSettings } = useSettings();
    const [activeColorId, setActiveColorId] = useState<string | null>(null);
    const [showAll, setShowAll] = useState(false);

    // Default color pool to pull from when adding new colors
    const defaultColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff', '#000000'];



    const handleAddColor = () => {
        if (colors.length >= 32) return;
        const nextColorHex = defaultColors[colors.length] || '#888888';
        setColors([...colors, { id: uuidv4(), hex: nextColorHex, threshold: 1.0 }]);
    };

    const handleRemoveColor = (id: string, e: React.MouseEvent) => {
        e.stopPropagation();
        if (colors.length <= 1) return; // Must have at least one color
        setColors(colors.filter(c => c.id !== id));
        if (activeColorId === id) setActiveColorId(null);
    };

    const handleColorChange = (newHex: string) => {
        if (!activeColorId) return;
        setColors(colors.map(c => c.id === activeColorId ? { ...c, hex: newHex } : c));
        updateSettings({ colorPaletteMode: 'manual' });
    };

    const handleThresholdChange = (id: string, value: number) => {
        setColors(colors.map((c: any) => c.id === id ? { ...c, threshold: value } : c));
        updateSettings({ colorPaletteMode: 'manual' });
    };

    const displayedColors = showAll ? colors : colors.slice(0, 8);

    return (
        <div className="bg-gray-900 border border-gray-800 rounded-lg p-4 space-y-4">

            <div className="flex items-center justify-between">
                <span className="text-[10px] text-gray-500 uppercase font-semibold flex items-center gap-1">
                    <PaintBucket size={12} />
                    Palette ({colors.length}/32)
                </span>
                <button
                    onClick={handleAddColor}
                    disabled={colors.length >= 32}
                    className="text-gray-400 hover:text-white disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                    title="Add Color"
                >
                    <Plus size={16} />
                </button>
            </div>

            <div className="space-y-1 max-h-64 overflow-y-auto pr-1 custom-scrollbar">
                {displayedColors.map((color) => (
                    <div key={color.id} className="group flex items-center gap-2 p-1.5 rounded bg-gray-950/50 hover:bg-gray-800 transition-colors border border-transparent hover:border-gray-700">
                        {/* Color Swatch */}
                        <div
                            className="w-5 h-5 rounded shadow-inner cursor-pointer flex-shrink-0 border border-gray-600"
                            style={{ backgroundColor: color.hex }}
                            onClick={() => setActiveColorId(activeColorId === color.id ? null : color.id)}
                            title="Click to edit color"
                        />

                        {/* Popover Color Picker (Modal Style) */}
                        {activeColorId === color.id && (
                            <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm pointer-events-auto" onClick={() => setActiveColorId(null)}>
                                <div className="relative bg-gray-950 p-5 rounded-2xl border border-gray-800 shadow-[0_0_40px_rgba(0,0,0,0.5)] flex flex-col items-center gap-4 animate-in zoom-in-95 duration-200" onClick={e => e.stopPropagation()}>
                                    <div className="flex justify-between items-center w-full">
                                        <span className="text-xs font-bold text-gray-400 uppercase tracking-widest">Edit Color</span>
                                        <button onClick={() => setActiveColorId(null)} className="text-gray-500 hover:text-white transition-colors bg-gray-900 rounded p-1"><X size={14} /></button>
                                    </div>
                                    <HexColorPicker color={color.hex} onChange={handleColorChange} />
                                    <div className="w-full text-center font-mono text-gray-300 bg-gray-900 py-1.5 rounded">{color.hex.toUpperCase()}</div>
                                </div>
                            </div>
                        )}

                        {/* Hex Display */}
                        <span className="text-xs font-mono text-gray-400 select-all uppercase w-14">{color.hex}</span>

                        {/* Minimum Divider */}
                        <div className="w-px h-3 bg-gray-700"></div>

                        {/* Threshold Slider Row (Compact) */}
                        <div className="flex items-center gap-1.5 flex-1 min-w-0">
                            <span className="text-[8px] text-gray-500 uppercase font-bold">THR</span>
                            <input
                                type="range"
                                min="0"
                                max="100"
                                step="1"
                                value={Math.round(color.threshold * 100)}
                                onChange={(e) => handleThresholdChange(color.id, parseInt(e.target.value) / 100)}
                                className="w-full h-1 bg-gray-700 hover:bg-gray-600 rounded-lg appearance-none cursor-pointer"
                                title="Per-Color Threshold"
                            />
                        </div>

                        {/* Value & Remove Button */}
                        <div className="flex items-center gap-1 justify-end w-14">
                            <span className="text-[9px] text-gray-500 font-mono text-right w-6 group-hover:hidden hidden sm:block">
                                {Math.round(color.threshold * 100)}
                            </span>
                            <button
                                onClick={(e) => handleRemoveColor(color.id, e)}
                                disabled={colors.length <= 1}
                                className="text-gray-600 hover:text-red-400 group-hover:opacity-100 sm:opacity-0 transition-opacity disabled:opacity-0 ml-auto"
                                title="Remove Color"
                            >
                                <X size={14} />
                            </button>
                        </div>
                    </div>
                ))}
            </div>

            {colors.length > 8 && (
                <button
                    onClick={() => setShowAll(!showAll)}
                    className="w-full text-xs font-bold text-gray-400 hover:text-white bg-gray-800 hover:bg-gray-700 border border-gray-700 py-1.5 rounded transition-colors"
                >
                    {showAll ? "Show Less" : "Show All Colors"}
                </button>
            )}

        </div>
    );
};

export default PaletteEditor;



============================================================
FILE: ./components\Sidebar.tsx
============================================================

import BlackWhiteControls from './BlackWhiteControls';
import ColorControls from './ColorControls';
import { useSettings } from '../context/SettingsContext';

const Sidebar: React.FC = () => {
    const { settings, updateSettings } = useSettings();

    return (
        <aside className="w-80 h-full bg-gray-950 flex flex-col overflow-y-auto shrink-0 border-r border-gray-800 shadow-2xl">
            {/* HEADER & GLOBAL UPLOAD */}
            <div className="p-6 border-b border-gray-800 sticky top-0 bg-gray-950/95 backdrop-blur z-10">
                <h1 className="text-2xl font-bold tracking-tighter text-white mb-6">DITHER<span className="text-gray-500">BOSS</span></h1>

                {/* Upload Button */}
                <label className="w-full flex items-center justify-center gap-2 bg-gray-100 hover:bg-white text-gray-950 px-4 py-3 rounded-md font-semibold cursor-pointer transition-colors tracking-wide shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" x2="12" y1="3" y2="15" /></svg>
                    UPLOAD IMAGE
                    <input
                        type="file"
                        accept="image/*"
                        className="hidden"
                        onChange={(e) => {
                            if (e.target.files && e.target.files.length > 0) {
                                const file = e.target.files[0];
                                const baseName = file.name.split('.').slice(0, -1).join('.') || 'ditherboss_export';
                                updateSettings({ originalFilename: baseName });
                                window.dispatchEvent(new CustomEvent('IMAGE_UPLOADED', { detail: file }));
                                e.target.value = ''; // Reset to allow same file re-upload
                            }
                        }}
                    />
                </label>
            </div>

            <div className="flex-1 p-6 space-y-8">

                {/* MODE TOGGLE */}
                <div className="space-y-3">
                    <label className="text-xs font-bold text-gray-400 tracking-widest uppercase">Process Mode</label>
                    <div className="flex p-1 bg-gray-900 rounded-lg border border-gray-800">
                        <button
                            onClick={() => updateSettings({ mode: 'bw' })}
                            className={`flex-1 py-2 text-sm font-semibold rounded-md transition-all ${settings.mode === 'bw'
                                ? 'bg-gray-700 text-white shadow-sm'
                                : 'text-gray-400 hover:text-gray-200 hover:bg-gray-800/50'
                                }`}
                        >
                            BLACK & WHITE
                        </button>
                        <button
                            onClick={() => updateSettings({ mode: 'color' })}
                            className={`flex-1 py-2 text-sm font-semibold rounded-md transition-all ${settings.mode === 'color'
                                ? 'bg-gray-700 text-white shadow-sm'
                                : 'text-gray-400 hover:text-gray-200 hover:bg-gray-800/50'
                                }`}
                        >
                            COLOR
                        </button>
                    </div>
                </div>

                {/* GLOBAL RESOLUTION & PIXEL SIZE (Moved Up) */}
                <div className="space-y-6">
                    <div className="space-y-3">
                        <label className="text-xs font-bold text-gray-500 tracking-widest uppercase flex justify-between">
                            <span>Resolution (Width)</span>
                            <span className="text-gray-300">{settings.width}px</span>
                        </label>
                        <input
                            type="range"
                            min="10"
                            max="3000"
                            value={settings.width}
                            onChange={(e) => updateSettings({ width: parseInt(e.target.value) })}
                            className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                        />
                    </div>

                    <div className="space-y-3">
                        <label className="text-xs font-bold text-gray-500 tracking-widest uppercase flex justify-between">
                            <span>Pixel Size</span>
                            <span className="text-gray-300">{settings.ditherScale}x</span>
                        </label>
                        <input
                            type="range"
                            min="1"
                            max="8"
                            step="1"
                            value={settings.ditherScale}
                            onChange={(e) => updateSettings({ ditherScale: parseInt(e.target.value) })}
                            className="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer"
                        />
                    </div>
                </div>

                <div className="h-px bg-gray-800 w-full" />

                {/* Dynamic Controls based on Mode */}
                {settings.mode === 'bw' ? <BlackWhiteControls /> : <ColorControls />}

            </div>

            {/* FOOTER & EXPORT */}
            <div className="p-6 border-t border-gray-800 bg-gray-950 mt-auto space-y-4 relative">
                <div className="absolute top-0 left-0 w-full h-px bg-gradient-to-r from-transparent via-gray-700 to-transparent"></div>

                <div className="flex items-center justify-between mb-4">
                    <h3 className="text-xs font-bold text-gray-400 tracking-widest uppercase text-center">Export Actions</h3>

                    {/* Pixel Fidelity Toggle */}
                    <label className="flex items-center gap-2 cursor-pointer group">
                        <span className="text-[10px] font-bold text-gray-500 group-hover:text-gray-300 transition-colors uppercase tracking-tighter">Pixel Fidelity</span>
                        <div
                            onClick={() => updateSettings({ pixelFidelity: !settings.pixelFidelity })}
                            className={`w-8 h-4 rounded-full p-0.5 transition-colors ${settings.pixelFidelity ? 'bg-indigo-600' : 'bg-gray-700'}`}
                        >
                            <div className={`w-3 h-3 bg-white rounded-full transition-transform ${settings.pixelFidelity ? 'translate-x-4' : 'translate-x-0'}`} />
                        </div>
                    </label>
                </div>

                <div className="grid grid-cols-2 gap-2">
                    <button
                        onClick={() => window.dispatchEvent(new CustomEvent('EXPORT_PNG'))}
                        className="w-full py-2.5 bg-blue-900/20 hover:bg-blue-800/40 text-blue-300 hover:text-blue-100 rounded-lg border border-blue-800/50 hover:border-blue-500/50 shadow-[0_0_15px_rgba(59,130,246,0.1)] hover:shadow-[0_0_20px_rgba(59,130,246,0.2)] transition-all text-xs font-semibold flex flex-col items-center justify-center gap-1 group backdrop-blur-sm"
                    >
                        <span className="group-hover:drop-shadow-[0_0_8px_rgba(96,165,250,0.8)] transition-all">PNG (Raster)</span>
                    </button>
                    <button
                        onClick={() => window.dispatchEvent(new CustomEvent('EXPORT_JPEG'))}
                        className="w-full py-2.5 bg-orange-900/20 hover:bg-orange-800/40 text-orange-300 hover:text-orange-100 rounded-lg border border-orange-800/50 hover:border-orange-500/50 shadow-[0_0_15px_rgba(249,115,22,0.1)] hover:shadow-[0_0_20px_rgba(249,115,22,0.2)] transition-all text-xs font-semibold flex flex-col items-center justify-center gap-1 group backdrop-blur-sm"
                    >
                        <span className="group-hover:drop-shadow-[0_0_8px_rgba(251,146,60,0.8)] transition-all">JPEG (Raster)</span>
                    </button>
                </div>

                <button
                    onClick={() => window.dispatchEvent(new CustomEvent('EXPORT_SVG'))}
                    className="w-full py-2.5 bg-green-900/20 hover:bg-green-800/40 text-green-300 hover:text-green-100 rounded-lg border border-green-800/50 hover:border-green-500/50 shadow-[0_0_15px_rgba(34,197,94,0.1)] hover:shadow-[0_0_20px_rgba(34,197,94,0.2)] transition-all text-sm font-semibold flex items-center justify-center gap-2 group backdrop-blur-sm"
                >
                    <span className="group-hover:drop-shadow-[0_0_8px_rgba(74,222,128,0.8)] transition-all">TRACE TO SVG</span>
                </button>

                <button
                    onClick={() => window.dispatchEvent(new CustomEvent('OPEN_BATCH'))}
                    className="w-full py-3 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white rounded-lg shadow-[0_0_20px_rgba(79,70,229,0.3)] hover:shadow-[0_0_25px_rgba(79,70,229,0.5)] transition-all text-sm font-bold flex items-center justify-center gap-2 mt-2 border border-indigo-400/30 backdrop-blur-sm group"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className="group-hover:scale-110 transition-transform"><path d="M21 8v13H3V8M1 3h22v5H1zM10 12h4" /></svg>
                    BATCH PROCESS
                </button>
            </div>
        </aside>
    );
};

export default Sidebar;



============================================================
FILE: ./components\Workspace.tsx
============================================================

import React, { useRef, useState, useEffect, useCallback } from 'react';
import { useSettings } from '../context/SettingsContext';
import { v4 as uuidv4 } from 'uuid';
import type { WorkerMessage, WorkerResponse, ProcessPayload } from '../worker/imageWorker';
import { exportRaster, exportSVG } from '../utils/exportUtils';

const Workspace: React.FC = () => {
    const { settings, updateSettings } = useSettings();
    const containerRef = useRef<HTMLDivElement>(null);
    const baseCanvasRef = useRef<HTMLCanvasElement>(null);
    const paintCanvasRef = useRef<HTMLCanvasElement>(null);
    const overlayCanvasRef = useRef<HTMLCanvasElement>(null);

    // Advanced Paint Engine State
    const isPaintingRef = useRef(false);
    const lastPosRef = useRef<{ x: number, y: number } | null>(null);

    // Viewport State
    const [scale, setScale] = useState(1);
    const [position, setPosition] = useState({ x: 0, y: 0 });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const [isHoveringFile, setIsHoveringFile] = useState(false);
    const [showOriginal, setShowOriginal] = useState(false);
    const [visualSize, setVisualSize] = useState({ width: 0, height: 0 });

    // Processing State
    const [sourceImage, setSourceImage] = useState<HTMLImageElement | null>(null);
    const [isProcessing, setIsProcessing] = useState(false);
    const [isExtracting, setIsExtracting] = useState(false);
    const workerRef = useRef<Worker | null>(null);
    const currentJobId = useRef<string | null>(null);
    const lastResultRef = useRef<ImageData | null>(null);

    // Initialize Worker
    useEffect(() => {
        workerRef.current = new Worker(new URL('../worker/imageWorker.ts', import.meta.url), { type: 'module' });

        workerRef.current.onmessage = (e: MessageEvent<WorkerResponse>) => {
            if (e.data.id === currentJobId.current) {
                if (e.data.type === 'RESULT' && e.data.imageData) {
                    lastResultRef.current = e.data.imageData; // Store for export
                    if (e.data.pixelCounts) {
                        updateSettings({ pixelCounts: e.data.pixelCounts });
                    }
                    const canvas = baseCanvasRef.current;
                    const paintCanvas = paintCanvasRef.current;
                    const overlayCanvas = overlayCanvasRef.current;
                    if (canvas && paintCanvas && overlayCanvas) {
                        const scale = settings.ditherScale || 1;
                        const w = e.data.imageData.width * scale;
                        const h = e.data.imageData.height * scale;

                        canvas.width = w;
                        canvas.height = h;

                        // Only resize paint/overlay if they don't match, to avoid clearing paint
                        if (paintCanvas.width !== w || paintCanvas.height !== h) {
                            paintCanvas.width = w;
                            paintCanvas.height = h;
                        }
                        if (overlayCanvas.width !== w || overlayCanvas.height !== h) {
                            overlayCanvas.width = w;
                            overlayCanvas.height = h;
                        }

                        const ctx = canvas.getContext('2d');
                        if (ctx) {
                            ctx.imageSmoothingEnabled = false;
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = e.data.imageData.width;
                            tempCanvas.height = e.data.imageData.height;
                            tempCanvas.getContext('2d')?.putImageData(e.data.imageData, 0, 0);
                            ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
                        }
                    }
                    setIsProcessing(false);
                } else if (e.data.type === 'RESULT' && e.data.payload) { // Extract Palette Result array
                    const hexColors = e.data.payload as string[];

                    // Maintain existing thresholds if possible
                    updateSettings({
                        colorPalette: hexColors.map((hex, idx) => ({
                            id: settings.colorPalette[idx]?.id || uuidv4(),
                            hex: hex,
                            threshold: settings.colorPalette[idx]?.threshold || 1.0
                        }))
                    });
                    setIsExtracting(false);
                    // The settings update will trigger the processImage useEffect naturally.
                } else if (e.data.type === 'ERROR') {
                    console.error('Worker Error:', e.data.error);
                    setIsProcessing(false);
                    setIsExtracting(false);
                }
            }
        };

        return () => {
            workerRef.current?.terminate();
        };
    }, []); // eslint-disable-line react-hooks/exhaustive-deps

    // Effect for Auto-Extraction Trigger
    // Trigger on image load, extract method change, or palette array SIZE change
    useEffect(() => {
        if (settings.mode !== 'color' || settings.colorPaletteMode !== 'auto' || !sourceImage || !workerRef.current) {
            if (settings.mode === 'bw') setIsExtracting(false); // Safety reset
            return;
        }

        console.log("Triggering auto-extraction due to change in mode/settings");
        triggerExtraction();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [sourceImage, settings.colorExtractMethod, settings.colorCount, settings.mode, settings.colorPaletteMode]);

    const triggerExtraction = () => {
        if (!sourceImage || !workerRef.current) return;
        setIsExtracting(true);

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 100; // Sample small for speed before sending
        tempCanvas.height = Math.round(sourceImage.height * (100 / sourceImage.width));
        const ctx = tempCanvas.getContext('2d');
        if (!ctx) return;
        ctx.drawImage(sourceImage, 0, 0, tempCanvas.width, tempCanvas.height);
        const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

        const jobId = uuidv4();
        currentJobId.current = jobId;

        workerRef.current.postMessage({
            type: 'EXTRACT_PALETTE',
            payload: { imageData, colorExtractMethod: settings.colorExtractMethod, colorPalette: settings.colorPalette, colorCount: settings.colorCount } as any,
            id: jobId
        });
    };

    // Main Process Image Trigger
    useEffect(() => {
        if (!sourceImage || !workerRef.current) return;
        if (isExtracting) return; // Wait for extraction to finish

        processImage();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        sourceImage,
        settings.mode,
        settings.width, settings.ditherScale, settings.colorCount,
        settings.bwThreshold, settings.bwMethod, settings.bwFactor, settings.bwStretch,
        settings.colorBlur, settings.colorPalette, isExtracting
    ]);

    const processImage = useCallback(() => {
        if (!sourceImage || !workerRef.current || isExtracting) return;
        setIsProcessing(true);

        const baseWidth = Math.min(settings.width, sourceImage.width);
        const baseHeight = Math.round(sourceImage.height * (baseWidth / sourceImage.width));

        const targetWidth = Math.max(1, Math.floor(baseWidth / settings.ditherScale));
        const targetHeight = Math.max(1, Math.floor(baseHeight / settings.ditherScale));

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = targetWidth;
        tempCanvas.height = targetHeight;
        const ctx = tempCanvas.getContext('2d', { willReadFrequently: true });
        if (!ctx) return;

        // Apply blur roughly if requested
        if (settings.colorBlur > 0) {
            ctx.filter = `blur(${settings.colorBlur}px)`;
        }
        ctx.drawImage(sourceImage, 0, 0, targetWidth, targetHeight);
        ctx.filter = 'none'; // reset
        const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);

        const jobId = uuidv4();
        currentJobId.current = jobId;

        const payload: ProcessPayload = {
            imageData,
            mode: settings.mode,
            width: targetWidth,
            bwThreshold: settings.bwThreshold,
            bwMethod: settings.bwMethod,
            bwFactor: settings.bwFactor,
            bwStretch: settings.bwStretch,
            colorBlur: settings.colorBlur,
            colorExtractMethod: settings.colorExtractMethod,
            colorPaletteMode: settings.colorPaletteMode,
            colorPalette: settings.colorPalette,
            colorCount: settings.colorCount
        };

        workerRef.current.postMessage({ type: 'PROCESS_IMAGE', payload, id: jobId } as WorkerMessage, [imageData.data.buffer]);
    }, [sourceImage, settings, isExtracting]);

    // Viewport Handling
    const handleWheel = useCallback((e: React.WheelEvent) => {
        e.preventDefault();
        if (!containerRef.current) return;
        const zoomSensitivity = 0.001;
        const delta = e.deltaY * -1;
        const newScale = Math.min(Math.max(0.1, scale + delta * zoomSensitivity * scale), 20);
        const rect = containerRef.current.getBoundingClientRect();
        const cursorX = e.clientX - rect.left - rect.width / 2;
        const cursorY = e.clientY - rect.top - rect.height / 2;
        const scaleRatio = newScale / scale;
        const newX = cursorX - (cursorX - position.x) * scaleRatio;
        const newY = cursorY - (cursorY - position.y) * scaleRatio;
        setScale(newScale);
        setPosition({ x: newX, y: newY });
    }, [scale, position]);

    useEffect(() => {
        const container = containerRef.current;
        if (container) {
            container.addEventListener('wheel', handleWheel as any, { passive: false });
            return () => container.removeEventListener('wheel', handleWheel as any);
        }
    }, [handleWheel]);

    const handleMouseDown = (e: React.MouseEvent) => {
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
            // Pan
            setIsDragging(true);
            setDragStart({ x: e.clientX - position.x, y: e.clientY - position.y });
        } else if (e.button === 0 && settings.activePaintColor && baseCanvasRef.current) {
            // Paint
            isPaintingRef.current = true;
            paintStroke(e.clientX, e.clientY);
        }
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (isDragging) {
            setPosition({ x: e.clientX - dragStart.x, y: e.clientY - dragStart.y });
        } else if (isPaintingRef.current) {
            paintStroke(e.clientX, e.clientY);
        }
    };

    const handleMouseUp = () => {
        setIsDragging(false);
        isPaintingRef.current = false;
        lastPosRef.current = null;
    };

    const hexToRgb = (hex: string) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    };

    // Calculate perceived brightness to find a darker shade
    const getBrightness = (r: number, g: number, b: number) => (r * 299 + g * 587 + b * 114) / 1000;

    const findDarkerSecondaryColor = (targetHex: string) => {
        const targetRgb = hexToRgb(targetHex);
        if (!targetRgb) return null;
        const targetLuma = getBrightness(targetRgb.r, targetRgb.g, targetRgb.b);

        let bestColor = null;
        let maxLumaDiff = -1;

        // Find the darkest color in palette that is darker than the active color
        for (const palC of settings.colorPalette) {
            const palRgb = hexToRgb(palC.hex);
            if (!palRgb) continue;
            const palLuma = getBrightness(palRgb.r, palRgb.g, palRgb.b);

            if (palLuma < targetLuma && (targetLuma - palLuma) > maxLumaDiff) {
                maxLumaDiff = targetLuma - palLuma;
                bestColor = palRgb;
            }
        }
        return bestColor;
    };

    const paintStroke = useCallback((clientX: number, clientY: number) => {
        const container = containerRef.current;
        const paintCanvas = paintCanvasRef.current;
        if (!container || !paintCanvas || !settings.activePaintColor) return;

        const rect = container.getBoundingClientRect();

        // Calculate relative coordinates from the container center taking panning/zooming into account
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;

        const displayWidth = paintCanvas.offsetWidth * scale;
        const displayHeight = paintCanvas.offsetHeight * scale;

        // Coordinate of the top-left of the image visually inside the container
        const imgLeft = centerX + position.x - (displayWidth / 2);
        const imgTop = centerY + position.y - (displayHeight / 2);

        // Map mouse to internal canvas resolution
        let canvasX = ((clientX - rect.left - imgLeft) / displayWidth) * paintCanvas.width;
        let canvasY = ((clientY - rect.top - imgTop) / displayHeight) * paintCanvas.height;

        canvasX = Math.floor(canvasX);
        canvasY = Math.floor(canvasY);

        if (canvasX < 0 || canvasX >= paintCanvas.width || canvasY < 0 || canvasY >= paintCanvas.height) return;

        const ctx = paintCanvas.getContext('2d', { willReadFrequently: true });
        if (!ctx) return;

        const activeRgb = hexToRgb(settings.activePaintColor);
        if (!activeRgb) return;

        const secondaryRgb = findDarkerSecondaryColor(settings.activePaintColor);

        const R = settings.brushSize;
        const H = settings.brushHardness / 100;
        const preset = settings.brushPreset;

        const minX = Math.max(0, canvasX - R);
        const maxX = Math.min(paintCanvas.width - 1, canvasX + R);
        const minY = Math.max(0, canvasY - R);
        const maxY = Math.min(paintCanvas.height - 1, canvasY + R);

        const imgData = ctx.getImageData(minX, minY, maxX - minX + 1, maxY - minY + 1);
        const data = imgData.data;
        const w = imgData.width;

        // Bayer matrices for dithering
        const bayer4 = [
            [0, 8, 2, 10],
            [12, 4, 14, 6],
            [3, 11, 1, 9],
            [15, 7, 13, 5]
        ];
        const bayer8 = [
            [0, 32, 8, 40, 2, 34, 10, 42],
            [48, 16, 56, 24, 50, 18, 58, 26],
            [12, 44, 4, 36, 14, 46, 6, 38],
            [60, 28, 52, 20, 62, 30, 54, 22],
            [3, 35, 11, 43, 1, 33, 9, 41],
            [51, 19, 59, 27, 49, 17, 57, 25],
            [15, 47, 7, 39, 13, 45, 5, 37],
            [63, 31, 55, 23, 61, 29, 53, 21]
        ];

        let hasMutated = false;

        for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
                const dx = x - canvasX;
                const dy = y - canvasY;
                const d = Math.sqrt(dx * dx + dy * dy);

                if (d > R) continue;

                let paintColor: { r: number, g: number, b: number } | null = null;

                if (d <= R * H) {
                    paintColor = activeRgb;
                } else if (d <= R) {
                    // Soft edge
                    const P = (R - d) / (R - (R * H));
                    let pass = false;

                    if (preset === 'solid') {
                        pass = false;
                    } else if (preset === 'dither') {
                        const matrix = R > 15 ? bayer8 : bayer4;
                        const div = R > 15 ? 64 : 16;
                        const size = R > 15 ? 8 : 4;
                        const thresholdMap = (matrix[y % size][x % size] + 0.5) / div;
                        pass = P > thresholdMap;
                    } else if (preset === 'noise') {
                        pass = P > Math.random();
                    }

                    if (pass) {
                        paintColor = activeRgb;
                    } else if (secondaryRgb) {
                        paintColor = secondaryRgb;
                    }
                }

                if (paintColor) {
                    const lx = x - minX;
                    const ly = y - minY;
                    const idx = (ly * w + lx) * 4;
                    data[idx] = paintColor.r;
                    data[idx + 1] = paintColor.g;
                    data[idx + 2] = paintColor.b;
                    data[idx + 3] = 255;
                    hasMutated = true;
                }
            }
        }

        if (hasMutated) {
            ctx.putImageData(imgData, minX, minY);
        }

    }, [scale, position, settings.activePaintColor, settings.brushSize, settings.brushHardness, settings.brushPreset, settings.colorPalette]);

    const handleDragOver = (e: React.DragEvent) => { e.preventDefault(); setIsHoveringFile(true); };
    const handleDragLeave = () => setIsHoveringFile(false);
    const handleDrop = (e: React.DragEvent) => {
        e.preventDefault();
        setIsHoveringFile(false);
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            handleFile(e.dataTransfer.files[0]);
        }
    };

    const handleFile = (file: File) => {
        if (!file.type.startsWith('image/')) return;
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
            setSourceImage(img);
            const baseVisualW = Math.min(1000, img.width);
            const baseVisualH = img.height * (baseVisualW / img.width);
            setVisualSize({ width: baseVisualW, height: baseVisualH });
            setScale(1);
            setPosition({ x: 0, y: 0 });
        };
        img.src = url;
    };

    useEffect(() => {
        const handleUploadEvent = (e: CustomEvent<File>) => handleFile(e.detail);
        window.addEventListener('IMAGE_UPLOADED', handleUploadEvent as EventListener);
        return () => window.removeEventListener('IMAGE_UPLOADED', handleUploadEvent as EventListener);
    }, []);

    // Export Listeners
    useEffect(() => {
        const getFilename = () => {
            const now = new Date();
            const pad = (n: number) => n.toString().padStart(2, '0');
            const dateStr = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}`;
            const timeStr = `${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
            return `${settings.originalFilename}_DitherBoss_${dateStr}_${timeStr}`;
        };

        const handlePNGExport = async () => {
            if (!lastResultRef.current || !sourceImage || !baseCanvasRef.current || !paintCanvasRef.current) return;

            const exportCanvas = document.createElement('canvas');

            // Composite base + paint
            const compositeCanvas = document.createElement('canvas');
            compositeCanvas.width = baseCanvasRef.current.width;
            compositeCanvas.height = baseCanvasRef.current.height;
            const compCtx = compositeCanvas.getContext('2d');
            if (compCtx) {
                compCtx.drawImage(baseCanvasRef.current, 0, 0);
                compCtx.drawImage(paintCanvasRef.current, 0, 0);
            }

            if (settings.pixelFidelity) {
                exportCanvas.width = compositeCanvas.width;
                exportCanvas.height = compositeCanvas.height;
                exportCanvas.getContext('2d')?.drawImage(compositeCanvas, 0, 0);
            } else {
                exportCanvas.width = sourceImage.width;
                exportCanvas.height = sourceImage.height;
                const ctx = exportCanvas.getContext('2d');
                if (ctx) {
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(compositeCanvas, 0, 0, exportCanvas.width, exportCanvas.height);
                }
            }
            exportRaster(exportCanvas, getFilename(), 'png', settings.exportDpi);
        };

        const handleJPEGExport = async () => {
            if (!lastResultRef.current || !sourceImage || !baseCanvasRef.current || !paintCanvasRef.current) return;

            const exportCanvas = document.createElement('canvas');

            const compositeCanvas = document.createElement('canvas');
            compositeCanvas.width = baseCanvasRef.current.width;
            compositeCanvas.height = baseCanvasRef.current.height;
            const compCtx = compositeCanvas.getContext('2d');
            if (compCtx) {
                compCtx.drawImage(baseCanvasRef.current, 0, 0);
                compCtx.drawImage(paintCanvasRef.current, 0, 0);
            }

            if (settings.pixelFidelity) {
                exportCanvas.width = compositeCanvas.width;
                exportCanvas.height = compositeCanvas.height;
                exportCanvas.getContext('2d')?.drawImage(compositeCanvas, 0, 0);
            } else {
                exportCanvas.width = sourceImage.width;
                exportCanvas.height = sourceImage.height;
                const ctx = exportCanvas.getContext('2d');
                if (ctx) {
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(compositeCanvas, 0, 0, exportCanvas.width, exportCanvas.height);
                }
            }
            exportRaster(exportCanvas, getFilename(), 'jpeg', settings.exportDpi);
        };

        const handleSVGExport = async () => {
            if (!lastResultRef.current || !baseCanvasRef.current || !paintCanvasRef.current) return;
            const hexArr = settings.colorPalette.map(c => c.hex);

            const compositeCanvas = document.createElement('canvas');
            compositeCanvas.width = baseCanvasRef.current.width;
            compositeCanvas.height = baseCanvasRef.current.height;
            const compCtx = compositeCanvas.getContext('2d');
            if (compCtx) {
                compCtx.drawImage(baseCanvasRef.current, 0, 0);
                compCtx.drawImage(paintCanvasRef.current, 0, 0);
            }

            exportSVG(compositeCanvas, getFilename(), settings.mode, hexArr);
        };

        window.addEventListener('EXPORT_PNG', handlePNGExport);
        window.addEventListener('EXPORT_JPEG', handleJPEGExport);
        window.addEventListener('EXPORT_SVG', handleSVGExport);
        return () => {
            window.removeEventListener('EXPORT_PNG', handlePNGExport);
            window.removeEventListener('EXPORT_JPEG', handleJPEGExport);
            window.removeEventListener('EXPORT_SVG', handleSVGExport);
        };
    }, [
        settings.exportDpi,
        settings.mode,
        settings.colorPalette,
        settings.pixelFidelity,
        settings.originalFilename,
        sourceImage,
        settings.pixelCounts // Add to trigger effect
    ]);

    // Handle Overlay rendering
    useEffect(() => {
        const baseCanvas = baseCanvasRef.current;
        const overlayCanvas = overlayCanvasRef.current;
        if (!baseCanvas || !overlayCanvas) return;

        const oCtx = overlayCanvas.getContext('2d', { willReadFrequently: true });
        if (!oCtx) return;

        // Clear overlay always
        oCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        if (!settings.hoveredColor) return; // Nothing hovered

        // Draw matching pixels to overlay
        const bCtx = baseCanvas.getContext('2d', { willReadFrequently: true });
        if (!bCtx) return;

        const imgData = bCtx.getImageData(0, 0, baseCanvas.width, baseCanvas.height);
        const data = imgData.data;

        // Try getting paint canvas pixels to composite
        const paintCanvas = paintCanvasRef.current;
        let paintData: Uint8ClampedArray | null = null;
        if (paintCanvas) {
            paintData = paintCanvas.getContext('2d', { willReadFrequently: true })?.getImageData(0, 0, paintCanvas.width, paintCanvas.height).data || null;
        }

        const outImgData = new ImageData(baseCanvas.width, baseCanvas.height);
        const outData = outImgData.data;

        const hr = parseInt(settings.hoveredColor.slice(1, 3), 16);
        const hg = parseInt(settings.hoveredColor.slice(3, 5), 16);
        const hb = parseInt(settings.hoveredColor.slice(5, 7), 16);

        for (let i = 0; i < data.length; i += 4) {
            let pr = data[i], pg = data[i + 1], pb = data[i + 2], pa = data[i + 3];

            // Override with paint layer if exists
            if (paintData && paintData[i + 3] > 0) {
                pr = paintData[i];
                pg = paintData[i + 1];
                pb = paintData[i + 2];
                pa = paintData[i + 3];
            }

            if (pa > 0 && Math.abs(pr - hr) < 5 && Math.abs(pg - hg) < 5 && Math.abs(pb - hb) < 5) {
                outData[i] = pr;
                outData[i + 1] = pg;
                outData[i + 2] = pb;
                outData[i + 3] = 255;
            }
        }
        oCtx.putImageData(outImgData, 0, 0);

    }, [settings.hoveredColor, lastResultRef.current]);

    return (
        <div
            className="flex-1 bg-gray-900 border-l border-gray-800 relative overflow-hidden flex items-center justify-center select-none"
            ref={containerRef}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
            style={{ cursor: isDragging ? 'grabbing' : 'grab' }}
        >
            <div
                className="absolute inset-0 opacity-20 pointer-events-none"
                style={{
                    backgroundImage: 'radial-gradient(#404040 1px, transparent 1px)',
                    backgroundSize: '20px 20px',
                    backgroundPosition: `${position.x}px ${position.y}px`,
                }}
            />

            {isHoveringFile && (
                <div className="absolute inset-0 z-50 bg-indigo-900/40 backdrop-blur-[2px] flex items-center justify-center transition-all">
                    <div className="p-8 border-2 border-indigo-400 border-dashed rounded-xl bg-gray-900/80 shadow-2xl">
                        <p className="text-xl font-bold tracking-widest text-indigo-200">DROP IMAGE HERE</p>
                    </div>
                </div>
            )}

            {!sourceImage ? (
                <div className="flex flex-col items-center justify-center text-gray-500 z-10 w-96 h-64 border-2 border-dashed border-gray-700/50 rounded-xl pointer-events-none bg-gray-900/50 backdrop-blur-sm">
                    <p className="text-xl font-medium tracking-tight text-gray-400 mb-2">Workspace</p>
                    <p className="text-sm">Drag and drop an image to begin.</p>
                </div>
            ) : (
                <div
                    className="relative z-10 origin-center"
                    style={{
                        transform: `translate(${position.x}px, ${position.y}px) scale(${scale})`,
                        transition: isDragging ? 'none' : 'transform 0.05s ease-out'
                    }}
                >
                    <div className="relative shadow-2xl ring-1 ring-gray-800 pointer-events-none">
                        {/* Layer 1: Base output */}
                        <canvas
                            ref={baseCanvasRef}
                            className="block rendering-pixelated relative z-10"
                            style={{
                                imageRendering: 'pixelated',
                                opacity: showOriginal ? 0 : (settings.hoveredColor ? 0.3 : 1),
                                filter: settings.hoveredColor ? 'grayscale(100%)' : 'none',
                                width: visualSize.width ? `${visualSize.width}px` : 'auto',
                                height: visualSize.height ? `${visualSize.height}px` : 'auto',
                            }}
                        />
                        {/* Layer 2: Paint (User Edits) */}
                        <canvas
                            ref={paintCanvasRef}
                            className="block rendering-pixelated absolute inset-0 z-20 pointer-events-none"
                            style={{
                                imageRendering: 'pixelated',
                                opacity: showOriginal ? 0 : (settings.hoveredColor ? 0.3 : 1),
                                filter: settings.hoveredColor ? 'grayscale(100%)' : 'none',
                                width: visualSize.width ? `${visualSize.width}px` : 'auto',
                                height: visualSize.height ? `${visualSize.height}px` : 'auto',
                            }}
                        />
                        {/* Layer 3: Overlay (Hover mask) */}
                        <canvas
                            ref={overlayCanvasRef}
                            className={`block rendering-pixelated absolute inset-0 z-30 pointer-events-none transition-opacity duration-200 ${settings.hoveredColor ? 'opacity-100' : 'opacity-0'}`}
                            style={{
                                imageRendering: 'pixelated',
                                width: visualSize.width ? `${visualSize.width}px` : 'auto',
                                height: visualSize.height ? `${visualSize.height}px` : 'auto',
                                filter: settings.hoveredColor ? `drop-shadow(0 0 10px ${settings.hoveredColor})` : 'none',
                            }}
                        />
                        {showOriginal && sourceImage && (
                            <img
                                src={sourceImage.src}
                                alt="Original"
                                className="absolute inset-0 object-cover"
                                style={{
                                    width: visualSize.width ? `${visualSize.width}px` : 'auto',
                                    height: visualSize.height ? `${visualSize.height}px` : 'auto',
                                }}
                            />
                        )}
                    </div>
                </div>
            )}

            {sourceImage && (
                <div className="absolute top-4 right-4 bg-gray-950/80 backdrop-blur border border-gray-800 px-3 py-1.5 rounded-lg shadow-lg z-20 flex items-center gap-4 text-[10px] font-mono text-gray-400">
                    <button
                        onMouseDown={() => setShowOriginal(true)}
                        onMouseUp={() => setShowOriginal(false)}
                        onMouseLeave={() => setShowOriginal(false)}
                        onTouchStart={(e) => { e.preventDefault(); setShowOriginal(true); }}
                        onTouchEnd={(e) => { e.preventDefault(); setShowOriginal(false); }}
                        className="bg-white/5 hover:bg-white/10 border border-white/10 text-gray-300 hover:text-white px-3 py-1.5 rounded-md backdrop-blur-md transition-all active:scale-95 uppercase font-bold tracking-widest pointer-events-auto shadow-sm"
                    >
                        Hold for Original
                    </button>

                    {(isProcessing || isExtracting) ? (
                        <span className="text-indigo-400 animate-pulse flex items-center gap-1">
                            <span className="w-1.5 h-1.5 rounded-full bg-indigo-400"></span> {isExtracting ? 'EXTRACTING PALETTE' : 'PROCESSING...'}
                        </span>
                    ) : (
                        <span className="text-green-500 font-semibold flex items-center gap-1">
                            <span className="w-1.5 h-1.5 rounded-full bg-green-500/50 border border-green-500"></span> READY
                        </span>
                    )}

                    <span>ZOOM: {Math.round(scale * 100)}%</span>
                    <button
                        onClick={(e) => { e.stopPropagation(); setScale(1); setPosition({ x: 0, y: 0 }); }}
                        className="hover:text-white transition-colors cursor-pointer mr-2"
                    >
                        RESET
                    </button>

                    {!settings.isAdvancedPanelOpen && (
                        <button
                            onClick={(e) => { e.stopPropagation(); updateSettings({ isAdvancedPanelOpen: true }); }}
                            className="bg-indigo-600/50 hover:bg-indigo-500/80 border border-indigo-400 text-white px-3 py-1.5 rounded-md transition-all uppercase tracking-widest font-bold shadow-[0_0_10px_rgba(79,70,229,0.2)]"
                        >
                            ADVANCED
                        </button>
                    )}
                </div>
            )}
        </div>
    );
};

export default Workspace;



============================================================
FILE: ./context\SettingsContext.tsx
============================================================

import React, { createContext, useContext, useState, type ReactNode } from 'react';
import type { PaletteColor } from '../components/PaletteEditor';
import { v4 as uuidv4 } from 'uuid';

interface AppSettings {
    // Global
    mode: 'bw' | 'color';
    width: number;
    exportDpi: 72 | 300;
    exportSize: number;
    ditherScale: number;
    originalFilename: string;
    pixelFidelity: boolean;

    // B&W
    bwThreshold: number;
    bwMethod: string;
    bwFactor: number;
    bwStretch: number;

    // Color
    colorBlur: number;
    colorPaletteMode: 'auto' | 'manual';
    colorExtractMethod: string;
    colorCount: number;
    colorPalette: PaletteColor[];

    // Advanced Paint System
    isAdvancedPanelOpen: boolean;
    brushSize: number;
    brushHardness: number;
    brushPreset: 'solid' | 'dither' | 'noise';
    activePaintColor: string | null;
    hoveredColor: string | null;
    pixelCounts: Record<string, number>;
}

interface SettingsContextType {
    settings: AppSettings;
    updateSettings: (newSettings: Partial<AppSettings>) => void;
}

const defaultSettings: AppSettings = {
    mode: 'bw',
    width: 1000,
    exportDpi: 72,
    exportSize: 1000,
    ditherScale: 1,
    originalFilename: 'ditherboss_export',
    pixelFidelity: true,

    bwThreshold: 100,
    bwMethod: 'floyd',
    bwFactor: 1.0,
    bwStretch: 0,

    colorBlur: 0,
    colorPaletteMode: 'auto',
    colorExtractMethod: 'kmeans',
    colorCount: 8,
    colorPalette: [
        { id: uuidv4(), hex: '#ff0000', threshold: 1.0 },
        { id: uuidv4(), hex: '#00ff00', threshold: 1.0 },
        { id: uuidv4(), hex: '#0000ff', threshold: 1.0 },
        { id: uuidv4(), hex: '#ffffff', threshold: 1.0 },
        { id: uuidv4(), hex: '#000000', threshold: 1.0 },
    ],

    isAdvancedPanelOpen: false,
    brushSize: 10,
    brushHardness: 100,
    brushPreset: 'solid',
    activePaintColor: null,
    hoveredColor: null,
    pixelCounts: {},
};

const SettingsContext = createContext<SettingsContextType | undefined>(undefined);

export const SettingsProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const [settings, setSettings] = useState<AppSettings>(defaultSettings);

    const updateSettings = (newSettings: Partial<AppSettings>) => {
        setSettings(prev => {
            const updated = { ...prev, ...newSettings };

            // Sync colorPalette array length with colorCount changes
            if (newSettings.colorCount !== undefined && newSettings.colorCount !== prev.colorCount) {
                const newCount = newSettings.colorCount;
                let newPalette = [...updated.colorPalette];

                if (newCount > newPalette.length) {
                    const defaultColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff', '#000000'];
                    while (newPalette.length < newCount) {
                        const nextColorHex = defaultColors[newPalette.length % defaultColors.length] || '#888888';
                        newPalette.push({ id: uuidv4(), hex: nextColorHex, threshold: 1.0 });
                    }
                } else if (newCount < newPalette.length) {
                    newPalette = newPalette.slice(0, newCount);
                }
                updated.colorPalette = newPalette;
            }

            return updated;
        });
    };

    return (
        <SettingsContext.Provider value={{ settings, updateSettings }}>
            {children}
        </SettingsContext.Provider>
    );
};

export const useSettings = () => {
    const context = useContext(SettingsContext);
    if (context === undefined) {
        throw new Error('useSettings must be used within a SettingsProvider');
    }
    return context;
};



============================================================
FILE: ./index.css
============================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-gray-950 text-gray-100 font-sans antialiased overflow-hidden;
  }
}

/* Custom Scrollbar for Sidebar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #171717;
}

::-webkit-scrollbar-thumb {
  background: #404040;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #525252;
}

/* Input Range overrides for sliders */
input[type=range] {
  accent-color: #d4d4d4;
}



============================================================
FILE: ./main.tsx
============================================================

import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import '@fontsource/space-grotesk';
import './index.css';
import App from './App.tsx';
import { SettingsProvider } from './context/SettingsContext';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <SettingsProvider>
      <App />
    </SettingsProvider>
  </StrictMode>,
);



============================================================
FILE: ./types\modules.d.ts
============================================================

declare module 'piexifjs';
declare module 'imagetracerjs';
declare module '@fontsource/space-grotesk';



============================================================
FILE: ./utils\exportUtils.ts
============================================================

import piexif from 'piexifjs';
// @ts-ignore
import ImageTracer from 'imagetracerjs';
import { saveAs } from 'file-saver';

/**
 * Injects DPI into a base64 Data URL (JPEG) using Exif metadata.
 */
function injectDPI(dataUrl: string, dpi: number): string {
    // Only works for JPEG with Piexif
    if (!dataUrl.startsWith('data:image/jpeg')) return dataUrl;

    try {
        const zeroth: any = {};
        zeroth[piexif.ImageIFD.XResolution] = [dpi, 1];
        zeroth[piexif.ImageIFD.YResolution] = [dpi, 1];
        zeroth[piexif.ImageIFD.ResolutionUnit] = 2; // Inches

        const exifObj = { "0th": zeroth };
        const exifBytes = piexif.dump(exifObj);
        return piexif.insert(exifBytes, dataUrl);
    } catch (e) {
        console.error("DPI injection failed:", e);
        return dataUrl;
    }
}

/**
 * Triggers a download of a raster image (PNG or JPG) from a canvas.
 */
export function exportRaster(canvas: HTMLCanvasElement, filename: string, format: 'png' | 'jpeg', dpi: 72 | 300) {
    if (format === 'png') {
        canvas.toBlob((blob) => {
            if (blob) {
                // Ensure filename has extension exactly once
                const cleanName = filename.toLowerCase().endsWith('.png') ? filename : `${filename}.png`;
                saveAs(blob, cleanName);
            }
        }, 'image/png');
    } else {
        const quality = 1.0;
        if (dpi === 300) {
            // For 300 DPI, we still need to convert to DataURL to inject EXIF
            const dataUrl = canvas.toDataURL('image/jpeg', quality);
            const finalDataUrl = injectDPI(dataUrl, 300);
            fetch(finalDataUrl)
                .then(res => res.blob())
                .then(blob => {
                    const cleanName = filename.toLowerCase().endsWith('.jpg') ? filename : `${filename}.jpg`;
                    saveAs(blob, cleanName);
                });
        } else {
            // Native blob saving for 72DPI (standard)
            canvas.toBlob((blob) => {
                if (blob) {
                    const cleanName = filename.toLowerCase().endsWith('.jpg') ? filename : `${filename}.jpg`;
                    saveAs(blob, cleanName);
                }
            }, 'image/jpeg', quality);
        }
    }
}

/**
 * Traces the canvas data to SVG using ImageTracer.js
 */
export function exportSVG(canvas: HTMLCanvasElement, filename: string, mode: 'bw' | 'color', paletteHex: string[]) {
    const dataUrl = canvas.toDataURL('image/png');

    // Config based on ImageTracer.js standard options
    const options: any = {
        scale: 1, // Don't scale the coordinates, keep pixel perfect
        corsenabled: false,
        layering: 0, // 0 for sequential layering
        // Settings tuned for pixelart style
        ltres: 0.1,
        qtres: 0.1,
        pathomit: 0,
        rightangleenhance: true,
    };

    if (mode === 'color' && paletteHex && paletteHex.length > 0) {
        // Custom palette
        options.pal = paletteHex.map(hex => {
            const r = parseInt(hex.substring(1, 3), 16);
            const g = parseInt(hex.substring(3, 5), 16);
            const b = parseInt(hex.substring(5, 7), 16);
            return { r, g, b, a: 255 };
        }).concat([{ r: 0, g: 0, b: 0, a: 0 }]); // Add trans
        options.colorquantcycles = 1;
    } else {
        // B&W
        options.pal = [
            { r: 0, g: 0, b: 0, a: 255 },
            { r: 255, g: 255, b: 255, a: 255 },
            { r: 0, g: 0, b: 0, a: 0 }
        ];
        options.colorquantcycles = 1;
    }

    ImageTracer.imageToSVG(
        dataUrl,
        (svgstr: string) => {
            const blob = new Blob([svgstr], { type: "image/svg+xml;charset=utf-8" });
            saveAs(blob, `${filename}.svg`);
        },
        options
    );
}



============================================================
FILE: ./worker\imageWorker.ts
============================================================

// src/worker/imageWorker.ts

export type WorkerMessageType = 'PROCESS_IMAGE' | 'EXTRACT_PALETTE';

export interface ProcessPayload {
    imageData: ImageData;
    mode: 'bw' | 'color';
    width: number;
    bwThreshold: number;
    bwMethod: string;
    bwFactor: number;
    bwStretch: number;
    colorBlur: number;
    colorExtractMethod: string;
    colorPaletteMode: string;
    colorPalette: any[];
    colorCount: number;
}

export interface WorkerMessage {
    type: WorkerMessageType;
    payload: ProcessPayload;
    id: string;
}

export interface WorkerResponse {
    type: 'RESULT' | 'ERROR' | 'PROGRESS';
    id: string;
    payload?: any;
    imageData?: ImageData;
    error?: string;
    progress?: number;
    pixelCounts?: Record<string, number>; // Added for Advanced System
}

export default {} as typeof Worker & { new(): Worker };

if (typeof self !== 'undefined') {
    self.addEventListener('message', async (e: MessageEvent<WorkerMessage>) => {
        const { type, payload, id } = e.data;
        try {
            if (type === 'PROCESS_IMAGE') {
                const { imageData: resultImageData, pixelCounts } = processImage(payload);
                (self as any).postMessage({
                    type: 'RESULT',
                    id,
                    imageData: resultImageData,
                    pixelCounts
                } as WorkerResponse, [resultImageData.data.buffer]);
            } else if (type === 'EXTRACT_PALETTE') {
                const colors = extractPalette(payload);
                (self as any).postMessage({
                    type: 'RESULT',
                    id,
                    payload: colors // Array of Hex strings
                } as WorkerResponse);
            }
        } catch (err: any) {
            (self as any).postMessage({
                type: 'ERROR',
                id,
                error: err.message
            } as WorkerResponse);
        }
    });
}

function processImage(opts: ProcessPayload): { imageData: ImageData, pixelCounts: Record<string, number> } {
    if (opts.mode === 'bw') {
        return processBlackAndWhite(opts);
    } else {
        return processColor(opts);
    }
}

const getLuminance = (r: number, g: number, b: number) => (r * 0.299 + g * 0.587 + b * 0.114);



function processBlackAndWhite(opts: ProcessPayload): { imageData: ImageData, pixelCounts: Record<string, number> } {
    const { imageData, bwThreshold, bwMethod, bwFactor, bwStretch } = opts;
    const width = imageData.width;
    const height = imageData.height;
    const data = new Uint8ClampedArray(imageData.data);

    // 1. Convert to Grayscale & Apply Stretch
    const grayData = new Float32Array(width * height);
    let minL = 255, maxL = 0;

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const l = getLuminance(r, g, b);
        grayData[i / 4] = l;
        if (l < minL) minL = l;
        if (l > maxL) maxL = l;
    }

    if (bwMethod === 'stretch' && bwStretch !== 0) {
        const range = maxL - minL || 1;
        const stretchMult = 1 + (bwStretch / 100);
        for (let i = 0; i < grayData.length; i++) {
            let normalized = (grayData[i] - minL) / range; // 0 to 1
            // Apply stretch around center 0.5
            normalized = ((normalized - 0.5) * stretchMult) + 0.5;
            grayData[i] = Math.max(0, Math.min(255, normalized * 255));
        }
    }

    // Helper to get/set pixel in 1D array
    const getP = (x: number, y: number) => {
        if (x < 0 || x >= width || y < 0 || y >= height) return 0;
        return grayData[y * width + x];
    };
    const addP = (x: number, y: number, amount: number) => {
        if (x < 0 || x >= width || y < 0 || y >= height) return;
        grayData[y * width + x] += amount;
    };

    // 2. Apply chosen Dithering Algorithm
    if (bwMethod === 'bitmap') {
        for (let i = 0; i < grayData.length; i++) {
            grayData[i] = grayData[i] > bwThreshold ? 255 : 0;
        }
    } else if (bwMethod === 'random') {
        for (let i = 0; i < grayData.length; i++) {
            const noise = (Math.random() - 0.5) * (bwFactor * 255);
            grayData[i] = (grayData[i] + noise) > bwThreshold ? 255 : 0;
        }
    } else if (bwMethod === 'floyd') {
        for (let y = 0; y < height; y++) {
            const reverse = y % 2 !== 0;
            const xStart = reverse ? width - 1 : 0;
            const xEnd = reverse ? -1 : width;
            const xStep = reverse ? -1 : 1;
            const dx = reverse ? -1 : 1;

            for (let x = xStart; x !== xEnd; x += xStep) {
                const oldVal = getP(x, y);
                const newVal = oldVal > bwThreshold ? 255 : 0;
                grayData[y * width + x] = newVal;
                const err = (oldVal - newVal) * bwFactor;

                addP(x + dx, y, err * 0.4375);
                addP(x - dx, y + 1, err * 0.1875);
                addP(x, y + 1, err * 0.3125);
                addP(x + dx, y + 1, err * 0.0625);
            }
        }
    } else if (bwMethod === 'atkinson') {
        for (let y = 0; y < height; y++) {
            const reverse = y % 2 !== 0;
            const xStart = reverse ? width - 1 : 0;
            const xEnd = reverse ? -1 : width;
            const xStep = reverse ? -1 : 1;
            const dx = reverse ? -1 : 1;

            for (let x = xStart; x !== xEnd; x += xStep) {
                const oldVal = getP(x, y);
                const newVal = oldVal > bwThreshold ? 255 : 0;
                grayData[y * width + x] = newVal;
                const err = (oldVal - newVal) * bwFactor;
                const eighth = err * 0.125;

                addP(x + dx, y, eighth);
                addP(x + 2 * dx, y, eighth);
                addP(x - dx, y + 1, eighth);
                addP(x, y + 1, eighth);
                addP(x + dx, y + 1, eighth);
                addP(x, y + 2, eighth);
            }
        }
    } else if (bwMethod === 'jarvis') {
        for (let y = 0; y < height; y++) {
            const reverse = y % 2 !== 0;
            const xStart = reverse ? width - 1 : 0;
            const xEnd = reverse ? -1 : width;
            const xStep = reverse ? -1 : 1;
            const dx = reverse ? -1 : 1;

            for (let x = xStart; x !== xEnd; x += xStep) {
                const oldVal = getP(x, y);
                const newVal = oldVal > bwThreshold ? 255 : 0;
                grayData[y * width + x] = newVal;
                const err = (oldVal - newVal) * bwFactor / 48;

                addP(x + dx, y, err * 7);
                addP(x + 2 * dx, y, err * 5);
                addP(x - 2 * dx, y + 1, err * 3);
                addP(x - dx, y + 1, err * 5);
                addP(x, y + 1, err * 7);
                addP(x + dx, y + 1, err * 5);
                addP(x + 2 * dx, y + 1, err * 3);
                addP(x - 2 * dx, y + 2, err * 1);
                addP(x - dx, y + 2, err * 3);
                addP(x, y + 2, err * 5);
                addP(x + dx, y + 2, err * 3);
                addP(x + 2 * dx, y + 2, err * 1);
            }
        }
    } else if (bwMethod === 'stucki') {
        for (let y = 0; y < height; y++) {
            const reverse = y % 2 !== 0;
            const xStart = reverse ? width - 1 : 0;
            const xEnd = reverse ? -1 : width;
            const xStep = reverse ? -1 : 1;
            const dx = reverse ? -1 : 1;

            for (let x = xStart; x !== xEnd; x += xStep) {
                const oldVal = getP(x, y);
                const newVal = oldVal > bwThreshold ? 255 : 0;
                grayData[y * width + x] = newVal;
                const err = (oldVal - newVal) * bwFactor / 42;

                addP(x + dx, y, err * 8);
                addP(x + 2 * dx, y, err * 4);
                addP(x - 2 * dx, y + 1, err * 2);
                addP(x - dx, y + 1, err * 4);
                addP(x, y + 1, err * 8);
                addP(x + dx, y + 1, err * 4);
                addP(x + 2 * dx, y + 1, err * 2);
                addP(x - 2 * dx, y + 2, err * 1);
                addP(x - dx, y + 2, err * 2);
                addP(x, y + 2, err * 4);
                addP(x + dx, y + 2, err * 2);
                addP(x + 2 * dx, y + 2, err * 1);
            }
        }
    } else if (bwMethod === 'bluenoise') {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const magic = 0.06711056 * x + 0.00583715 * y;
                const ign = (52.9829189 * (magic - Math.floor(magic))) % 1.0;
                const bias = (ign - 0.5) * (bwFactor * 255);
                const val = (getP(x, y) + bias) > bwThreshold ? 255 : 0;
                grayData[y * width + x] = val;
            }
        }
    } else if (bwMethod.startsWith('bayer') || bwMethod.startsWith('clustered')) {
        let matrix: number[][] = [];
        let size = 2;
        let div = 4;

        if (bwMethod === 'bayer2') {
            matrix = [[0, 2], [3, 1]];
            size = 2;
            div = 4;
        } else if (bwMethod === 'bayer4') {
            matrix = [
                [0, 8, 2, 10],
                [12, 4, 14, 6],
                [3, 11, 1, 9],
                [15, 7, 13, 5]
            ];
            size = 4;
            div = 16;
        } else if (bwMethod === 'bayer8') {
            matrix = [
                [0, 32, 8, 40, 2, 34, 10, 42],
                [48, 16, 56, 24, 50, 18, 58, 26],
                [12, 44, 4, 36, 14, 46, 6, 38],
                [60, 28, 52, 20, 62, 30, 54, 22],
                [3, 35, 11, 43, 1, 33, 9, 41],
                [51, 19, 59, 27, 49, 17, 57, 25],
                [15, 47, 7, 39, 13, 45, 5, 37],
                [63, 31, 55, 23, 61, 29, 53, 21]
            ];
            size = 8;
            div = 64;
        } else if (bwMethod === 'clustered4') {
            matrix = [
                [12, 5, 6, 13],
                [4, 0, 1, 7],
                [11, 3, 2, 8],
                [15, 10, 9, 14]
            ];
            size = 4;
            div = 16;
        }

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const oldVal = getP(x, y);
                const thresholdMap = (matrix[y % size][x % size] + 0.5) / div * 255;
                const bias = bwThreshold - 128; // Bias slider
                const newVal = (oldVal + bias) > thresholdMap ? 255 : 0;
                grayData[y * width + x] = newVal;
            }
        }
    }

    // 3. Reconstruct ImageData & Count Pixels
    const pixelCounts: Record<string, number> = {};
    for (let i = 0; i < data.length; i += 4) {
        const p = grayData[i / 4] > 127 ? 255 : 0; // It's already clamped to 0 or 255 by logic above, except stretch
        const oldA = data[i + 3];
        const finalA = oldA === 0 ? 0 : 255;
        data[i] = p;
        data[i + 1] = p;
        data[i + 2] = p;
        data[i + 3] = finalA; // Preserve transparent holes

        if (finalA > 0) {
            const hex = "#" + (1 << 24 | p << 16 | p << 8 | p).toString(16).slice(1);
            pixelCounts[hex] = (pixelCounts[hex] || 0) + 1;
        }
    }

    return { imageData: new ImageData(data, width, height), pixelCounts };
}

// === COLOR PROCESSING ===

function processColor(opts: ProcessPayload): { imageData: ImageData, pixelCounts: Record<string, number> } {
    const { imageData, colorPalette, bwMethod, bwFactor, bwStretch } = opts;
    const width = imageData.width;
    const height = imageData.height;
    const data = new Uint8ClampedArray(imageData.data);

    const paletteCount = colorPalette.length;
    const paletteData = new Float32Array(paletteCount * 4); // r, g, b, threshold
    for (let j = 0; j < paletteCount; j++) {
        const hex = colorPalette[j].hex.replace('#', '');
        paletteData[j * 4] = parseInt(hex.substring(0, 2), 16);
        paletteData[j * 4 + 1] = parseInt(hex.substring(2, 4), 16);
        paletteData[j * 4 + 2] = parseInt(hex.substring(4, 6), 16);
        paletteData[j * 4 + 3] = colorPalette[j].threshold;
    }

    const addP = (x: number, y: number, errR: number, errG: number, errB: number) => {
        if (x < 0 || x >= width || y < 0 || y >= height) return;
        const i = (y * width + x) * 4;
        data[i] = Math.max(0, Math.min(255, data[i] + errR));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + errG));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + errB));
    };

    let isOrdered = false;
    let mSize = 2;
    let matrixDiv = 4;
    let matrix: number[][] = [];
    if (bwMethod === 'bayer2') {
        isOrdered = true; matrix = [[0, 2], [3, 1]]; mSize = 2; matrixDiv = 4;
    } else if (bwMethod === 'bayer4') {
        isOrdered = true; matrix = [[0, 8, 2, 10], [12, 4, 14, 6], [3, 11, 1, 9], [15, 7, 13, 5]]; mSize = 4; matrixDiv = 16;
    } else if (bwMethod === 'bayer8') {
        isOrdered = true; matrix = [
            [0, 32, 8, 40, 2, 34, 10, 42],
            [48, 16, 56, 24, 50, 18, 58, 26],
            [12, 44, 4, 36, 14, 46, 6, 38],
            [60, 28, 52, 20, 62, 30, 54, 22],
            [3, 35, 11, 43, 1, 33, 9, 41],
            [51, 19, 59, 27, 49, 17, 57, 25],
            [15, 47, 7, 39, 13, 45, 5, 37],
            [63, 31, 55, 23, 61, 29, 53, 21]
        ]; mSize = 8; matrixDiv = 64;
    } else if (bwMethod === 'clustered4') {
        isOrdered = true; matrix = [
            [12, 5, 6, 13],
            [4, 0, 1, 7],
            [11, 3, 2, 8],
            [15, 10, 9, 14]
        ]; mSize = 4; matrixDiv = 16;
    }

    for (let y = 0; y < height; y++) {
        const reverse = (['floyd', 'atkinson', 'jarvis', 'stucki'].includes(bwMethod)) && (y % 2 !== 0);
        const xStart = reverse ? width - 1 : 0;
        const xEnd = reverse ? -1 : width;
        const xStep = reverse ? -1 : 1;
        const dx = reverse ? -1 : 1;

        for (let x = xStart; x !== xEnd; x += xStep) {
            const i = (y * width + x) * 4;

            const oldA = data[i + 3];
            // Removed: if (data[i + 3] === 0) continue; // Allow transparency holes to diffuse error

            const oldR = data[i];
            const oldG = data[i + 1];
            const oldB = data[i + 2];

            let queryR = oldR;
            let queryG = oldG;
            let queryB = oldB;

            if (bwMethod === 'stretch') {
                const stretchMult = 1 + (bwStretch / 100);
                const shift = ((stretchMult - 1) * 255) / 2;
                queryR = (oldR * stretchMult) - shift;
                queryG = (oldG * stretchMult) - shift;
                queryB = (oldB * stretchMult) - shift;
            } else if (bwMethod === 'random') {
                const bias = (Math.random() - 0.5) * (bwFactor * 255);
                queryR = oldR + bias;
                queryG = oldG + bias;
                queryB = oldB + bias;
            } else if (bwMethod === 'bluenoise') {
                const magic = 0.06711056 * x + 0.00583715 * y;
                const ign = (52.9829189 * (magic - Math.floor(magic))) % 1.0;
                const bias = (ign - 0.5) * (bwFactor * 255);
                queryR = oldR + bias;
                queryG = oldG + bias;
                queryB = oldB + bias;
            } else if (isOrdered) {
                const bVal = matrix[y % mSize][x % mSize];
                const bias = (((bVal + 0.5) / matrixDiv) - 0.5) * (bwFactor * 255);
                queryR = oldR + bias;
                queryG = oldG + bias;
                queryB = oldB + bias;
            }

            queryR = Math.max(0, Math.min(255, queryR));
            queryG = Math.max(0, Math.min(255, queryG));
            queryB = Math.max(0, Math.min(255, queryB));

            let closestIdx = 0;
            let minDist = Infinity;

            for (let j = 0; j < paletteCount; j++) {
                const pr = paletteData[j * 4];
                const pg = paletteData[j * 4 + 1];
                const pb = paletteData[j * 4 + 2];

                // Inline Redmean Distance
                const r_mean = (queryR + pr) / 2;
                const dr = queryR - pr;
                const dg = queryG - pg;
                const db = queryB - pb;
                const dist = (2 + r_mean / 256) * dr * dr + 4 * dg * dg + (2 + (255 - r_mean) / 256) * db * db;

                if (dist < minDist) {
                    minDist = dist;
                    closestIdx = j;
                }
            }

            const matchColorR = paletteData[closestIdx * 4];
            const matchColorG = paletteData[closestIdx * 4 + 1];
            const matchColorB = paletteData[closestIdx * 4 + 2];
            const matchThreshold = paletteData[closestIdx * 4 + 3];

            const L = getLuminance(oldR, oldG, oldB) / 255.0;

            if (L <= matchThreshold) {
                data[i] = matchColorR;
                data[i + 1] = matchColorG;
                data[i + 2] = matchColorB;
                data[i + 3] = oldA === 0 ? 0 : 255; // Preserve transparent holes
            } else {
                data[i] = 0;
                data[i + 1] = 0;
                data[i + 2] = 0;
                data[i + 3] = 0;
            }

            const errR = (oldR - matchColorR) * bwFactor;
            const errG = (oldG - matchColorG) * bwFactor;
            const errB = (oldB - matchColorB) * bwFactor;

            if (bwMethod === 'floyd') {
                addP(x + dx, y, errR * 0.4375, errG * 0.4375, errB * 0.4375);
                addP(x - dx, y + 1, errR * 0.1875, errG * 0.1875, errB * 0.1875);
                addP(x, y + 1, errR * 0.3125, errG * 0.3125, errB * 0.3125);
                addP(x + dx, y + 1, errR * 0.0625, errG * 0.0625, errB * 0.0625);
            } else if (bwMethod === 'atkinson') {
                const eighthR = errR * 0.125, eighthG = errG * 0.125, eighthB = errB * 0.125;
                addP(x + dx, y, eighthR, eighthG, eighthB);
                addP(x + 2 * dx, y, eighthR, eighthG, eighthB);
                addP(x - dx, y + 1, eighthR, eighthG, eighthB);
                addP(x, y + 1, eighthR, eighthG, eighthB);
                addP(x + dx, y + 1, eighthR, eighthG, eighthB);
                addP(x, y + 2, eighthR, eighthG, eighthB);
            } else if (bwMethod === 'jarvis') {
                const r48 = errR / 48, g48 = errG / 48, b48 = errB / 48;
                addP(x + dx, y, r48 * 7, g48 * 7, b48 * 7);
                addP(x + 2 * dx, y, r48 * 5, g48 * 5, b48 * 5);
                addP(x - 2 * dx, y + 1, r48 * 3, g48 * 3, b48 * 3);
                addP(x - dx, y + 1, r48 * 5, g48 * 5, b48 * 5);
                addP(x, y + 1, r48 * 7, g48 * 7, b48 * 7);
                addP(x + dx, y + 1, r48 * 5, g48 * 5, b48 * 5);
                addP(x + 2 * dx, y + 1, r48 * 3, g48 * 3, b48 * 3);
                addP(x - 2 * dx, y + 2, r48 * 1, g48 * 1, b48 * 1);
                addP(x - dx, y + 2, r48 * 3, g48 * 3, b48 * 3);
                addP(x, y + 2, r48 * 5, g48 * 5, b48 * 5);
                addP(x + dx, y + 2, r48 * 3, g48 * 3, b48 * 3);
                addP(x + 2 * dx, y + 2, r48 * 1, g48 * 1, b48 * 1);
            } else if (bwMethod === 'stucki') {
                const r42 = errR / 42, g42 = errG / 42, b42 = errB / 42;
                addP(x + dx, y, r42 * 8, g42 * 8, b42 * 8);
                addP(x + 2 * dx, y, r42 * 4, g42 * 4, b42 * 4);
                addP(x - 2 * dx, y + 1, r42 * 2, g42 * 2, b42 * 2);
                addP(x - dx, y + 1, r42 * 4, g42 * 4, b42 * 4);
                addP(x, y + 1, r42 * 8, g42 * 8, b42 * 8);
                addP(x + dx, y + 1, r42 * 4, g42 * 4, b42 * 4);
                addP(x + 2 * dx, y + 1, r42 * 2, g42 * 2, b42 * 2);
                addP(x - 2 * dx, y + 2, r42 * 1, g42 * 1, b42 * 1);
                addP(x - dx, y + 2, r42 * 2, g42 * 2, b42 * 2);
                addP(x, y + 2, r42 * 4, g42 * 4, b42 * 4);
                addP(x + dx, y + 2, r42 * 2, g42 * 2, b42 * 2);
                addP(x + 2 * dx, y + 2, r42 * 1, g42 * 1, b42 * 1);
            }
        }
    }

    const pixelCounts: Record<string, number> = {};
    for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] > 0) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const hex = "#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);
            pixelCounts[hex] = (pixelCounts[hex] || 0) + 1;
        }
    }

    return { imageData: new ImageData(data, width, height), pixelCounts };
}

// Helper: LAB Conversion
function rgbToLab(r: number, g: number, b: number) {
    let r_s = r / 255, g_s = g / 255, b_s = b / 255;
    r_s = r_s > 0.04045 ? Math.pow((r_s + 0.055) / 1.055, 2.4) : r_s / 12.92;
    g_s = g_s > 0.04045 ? Math.pow((g_s + 0.055) / 1.055, 2.4) : g_s / 12.92;
    b_s = b_s > 0.04045 ? Math.pow((b_s + 0.055) / 1.055, 2.4) : b_s / 12.92;
    const x = (r_s * 0.4124 + g_s * 0.3576 + b_s * 0.1805) / 0.95047;
    const y = (r_s * 0.2126 + g_s * 0.7152 + b_s * 0.0722) / 1.00000;
    const z = (r_s * 0.0193 + g_s * 0.1192 + b_s * 0.9505) / 1.08883;
    const fx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + 16 / 116;
    const fy = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + 16 / 116;
    const fz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + 16 / 116;
    return [(116 * fy) - 16, 500 * (fx - fy), 200 * (fy - fz)];
}

export function extractPalette(opts: ProcessPayload): string[] {
    const { imageData, colorExtractMethod, colorPalette } = opts;
    const targetK = colorPalette.length;
    const data = imageData.data;

    // 1. Sample max 10,000 pixels for speed
    const samples: { r: number, g: number, b: number }[] = [];
    const step = Math.max(1, Math.floor((data.length / 4) / 10000));

    for (let i = 0; i < data.length; i += 4 * step) {
        if (data[i + 3] > 0) {
            samples.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
        }
    }

    if (samples.length === 0) return Array(targetK).fill('#000000');

    if (colorExtractMethod === 'kmeans') {
        return extractKMeans(samples, targetK);
    } else if (colorExtractMethod === 'histogram') {
        return extractHistogram(samples, targetK);
    } else if (colorExtractMethod === 'hue') {
        return extractHueClustering(samples, targetK);
    } else if (colorExtractMethod === 'extreme') {
        return extractExtreme(samples, targetK);
    } else if (colorExtractMethod === 'pronounced') {
        return extractPronounced(samples, targetK);
    } else if (colorExtractMethod === 'varied') {
        return extractVaried(samples, targetK);
    } else if (colorExtractMethod === 'distant') {
        return extractDistant(samples, targetK);
    } else if (colorExtractMethod === 'contrasting') {
        return extractContrasting(samples, targetK);
    } else {
        return extractMedianCut(samples, targetK);
    }
}

// Simple K-Means in LAB space as requested for human eye accuracy
// Helper functions defined above
function extractKMeans(samples: { r: number, g: number, b: number }[], k: number): string[] {
    // We convert samples to lab once
    const labSamples = samples.map(s => {
        const lab = rgbToLab(s.r, s.g, s.b);
        return { l: lab[0], a: lab[1], b: lab[2], point: s };
    });

    let centroids = [];
    for (let i = 0; i < k; i++) {
        centroids.push(labSamples[Math.floor(Math.random() * labSamples.length)]);
    }

    let iterations = 0;
    let changed = true;
    let assignments = new Array(labSamples.length).fill(0);

    while (changed && iterations < 20) {
        changed = false;
        iterations++;

        for (let i = 0; i < labSamples.length; i++) {
            const p = labSamples[i];
            let minDist = Infinity;
            let bestK = 0;
            for (let j = 0; j < k; j++) {
                const c = centroids[j];
                const dist = (p.l - c.l) ** 2 + (p.a - c.a) ** 2 + (p.b - c.b) ** 2;
                if (dist < minDist) {
                    minDist = dist;
                    bestK = j;
                }
            }
            if (assignments[i] !== bestK) {
                changed = true;
                assignments[i] = bestK;
            }
        }

        const sums = Array.from({ length: k }, () => ({ l: 0, a: 0, b: 0, point: { r: 0, g: 0, b: 0 }, count: 0 }));
        for (let i = 0; i < labSamples.length; i++) {
            const cluster = assignments[i];
            sums[cluster].l += labSamples[i].l;
            sums[cluster].a += labSamples[i].a;
            sums[cluster].b += labSamples[i].b;
            sums[cluster].point.r += labSamples[i].point.r; // Accumulate RGB to easily get average RGB 
            sums[cluster].point.g += labSamples[i].point.g;
            sums[cluster].point.b += labSamples[i].point.b;
            sums[cluster].count += 1;
        }

        for (let j = 0; j < k; j++) {
            if (sums[j].count > 0) {
                centroids[j] = {
                    l: sums[j].l / sums[j].count,
                    a: sums[j].a / sums[j].count,
                    b: sums[j].b / sums[j].count,
                    point: {
                        r: Math.round(sums[j].point.r / sums[j].count),
                        g: Math.round(sums[j].point.g / sums[j].count),
                        b: Math.round(sums[j].point.b / sums[j].count),
                    }
                };
            }
        }
    }

    return centroids.map(c => rgbToHex(c.point.r, c.point.g, c.point.b));
}

// Median Cut implementation natively uses RGB as requested "greatest range"
function extractMedianCut(samples: { r: number, g: number, b: number }[], k: number): string[] {
    let boxes = [samples];

    while (boxes.length < k) {
        let splitBoxIdx = -1;
        let maxRange = -1;
        let longestChannel: 'r' | 'g' | 'b' = 'r';

        for (let i = 0; i < boxes.length; i++) {
            const box = boxes[i];
            if (box.length < 2) continue;
            let minR = 255, maxR = 0, minG = 255, maxG = 0, minB = 255, maxB = 0;
            for (let j = 0; j < box.length; j++) {
                const p = box[j];
                if (p.r < minR) minR = p.r; if (p.r > maxR) maxR = p.r;
                if (p.g < minG) minG = p.g; if (p.g > maxG) maxG = p.g;
                if (p.b < minB) minB = p.b; if (p.b > maxB) maxB = p.b;
            }
            const rRange = maxR - minR;
            const gRange = maxG - minG;
            const bRange = maxB - minB;

            const currentMax = Math.max(rRange, gRange, bRange);
            if (currentMax > maxRange) {
                maxRange = currentMax;
                splitBoxIdx = i;
                if (currentMax === rRange) longestChannel = 'r';
                else if (currentMax === gRange) longestChannel = 'g';
                else longestChannel = 'b';
            }
        }

        if (splitBoxIdx === -1) break;

        const targetBox = boxes[splitBoxIdx];
        targetBox.sort((a, b) => a[longestChannel] - b[longestChannel]);
        const mid = Math.floor(targetBox.length / 2);
        const box1 = targetBox.slice(0, mid);
        const box2 = targetBox.slice(mid);

        boxes.splice(splitBoxIdx, 1, box1, box2);
    }

    return boxes.map(box => {
        let rSum = 0, gSum = 0, bSum = 0;
        for (let i = 0; i < box.length; i++) {
            rSum += box[i].r; gSum += box[i].g; bSum += box[i].b;
        }
        return rgbToHex(Math.round(rSum / box.length), Math.round(gSum / box.length), Math.round(bSum / box.length));
    });
}

function rgbToHex(r: number, g: number, b: number) {
    return "#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);
}

function rgbToHsl(r: number, g: number, b: number) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s = 0, l = (max + min) / 2;
    if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return [h * 360, s * 100, l * 100];
}

function extractHistogram(samples: { r: number, g: number, b: number }[], k: number): string[] {
    const counts = new Map<string, number>();
    for (const s of samples) {
        const qr = (s.r >> 3) << 3;
        const qg = (s.g >> 3) << 3;
        const qb = (s.b >> 3) << 3;
        const key = `${qr},${qg},${qb}`;
        counts.set(key, (counts.get(key) || 0) + 1);
    }
    const sorted = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    const res = sorted.slice(0, k).map(entry => {
        const [r, g, b] = entry[0].split(',').map(Number);
        return rgbToHex(r, g, b);
    });
    while (res.length < k) res.push("#000000");
    return res;
}

function extractHueClustering(samples: { r: number, g: number, b: number }[], k: number): string[] {
    const bins = Array.from({ length: 36 }, () => [] as { h: number, s: number, l: number, r: number, g: number, b: number }[]);
    for (const s of samples) {
        const [h, sat, l] = rgbToHsl(s.r, s.g, s.b);
        const binIdx = Math.floor(h / 10) % 36;
        bins[binIdx].push({ h, s: sat, l, r: s.r, g: s.g, b: s.b });
    }
    bins.sort((a, b) => b.length - a.length);
    const topBins = bins.slice(0, k);
    const result: string[] = [];
    for (const bin of topBins) {
        if (bin.length === 0) continue;
        let best = bin[0];
        for (const p of bin) if (p.s > best.s) best = p;
        result.push(rgbToHex(best.r, best.g, best.b));
    }
    while (result.length < k) result.push("#000000");
    return result.slice(0, k);
}

function extractExtreme(samples: { r: number, g: number, b: number }[], k: number): string[] {
    const hsmap = samples.map(s => {
        const [h, sat, l] = rgbToHsl(s.r, s.g, s.b);
        return { r: s.r, g: s.g, b: s.b, h, s: sat, l };
    });
    const lightest = [...hsmap].sort((a, b) => b.l - a.l)[0];
    const darkest = [...hsmap].sort((a, b) => a.l - b.l)[0];
    const mostSat = [...hsmap].sort((a, b) => b.s - a.s)[0];
    const leastSat = [...hsmap].sort((a, b) => a.s - b.s)[0];
    const resultColors = [lightest, darkest, mostSat, leastSat].filter(x => x !== undefined);

    if (resultColors.length < k) {
        const mids = [...hsmap].sort((a, b) => Math.abs(a.l - 50) - Math.abs(b.l - 50));
        for (const m of mids) {
            if (resultColors.length >= k) break;
            if (!resultColors.includes(m)) resultColors.push(m);
        }
    }
    const res = resultColors.slice(0, k).map(c => rgbToHex(c.r, c.g, c.b));
    while (res.length < k) res.push("#000000");
    return res;
}

function extractPronounced(samples: { r: number, g: number, b: number }[], k: number): string[] {
    const scored = samples.map(s => {
        const [, sat, l] = rgbToHsl(s.r, s.g, s.b);
        const score = sat * (1 - Math.abs(l - 50) / 50);
        return { r: s.r, g: s.g, b: s.b, score };
    });
    scored.sort((a, b) => b.score - a.score);
    const res: string[] = [];
    const seen = new Set<string>();
    for (const s of scored) {
        const hex = rgbToHex(s.r, s.g, s.b);
        if (!seen.has(hex)) {
            seen.add(hex);
            res.push(hex);
        }
        if (res.length === k) break;
    }
    while (res.length < k) res.push("#000000");
    return res;
}

function extractVaried(samples: { r: number, g: number, b: number }[], k: number): string[] {
    const bins = Array.from({ length: 36 }, () => [] as { h: number, s: number, l: number, r: number, g: number, b: number }[]);
    for (const s of samples) {
        const [h, sat, l] = rgbToHsl(s.r, s.g, s.b);
        const binIdx = Math.floor(h / 10) % 36;
        bins[binIdx].push({ h, s: sat, l, r: s.r, g: s.g, b: s.b });
    }

    const populatedBins = bins.map((b, i) => ({ idx: i, bin: b })).filter(x => x.bin.length > 0);
    if (populatedBins.length === 0) return Array(k).fill("#000000");

    const result: string[] = [];
    const step = Math.max(1, populatedBins.length / k);
    for (let i = 0; i < k; i++) {
        const targetIdx = Math.floor(i * step) % populatedBins.length;
        const bin = populatedBins[targetIdx].bin;
        if (bin && bin.length > 0) {
            let best = bin[0];
            for (const p of bin) if (p.s > best.s) best = p;
            const hex = rgbToHex(best.r, best.g, best.b);
            if (!result.includes(hex)) result.push(hex);
        }
    }
    if (result.length < k) {
        let allColors = [];
        for (const bin of bins) {
            let best = bin[0];
            if (!best) continue;
            for (const p of bin) if (p.s > best.s) best = p;
            allColors.push(best);
        }
        allColors.sort((a, b) => b.s - a.s);
        for (const c of allColors) {
            if (result.length >= k) break;
            const hex = rgbToHex(c.r, c.g, c.b);
            if (!result.includes(hex)) result.push(hex);
        }
    }
    while (result.length < k) result.push("#000000");
    return result.slice(0, k);
}

function extractDistant(samples: { r: number, g: number, b: number }[], k: number): string[] {
    const labSamples = samples.map(s => {
        const lab = rgbToLab(s.r, s.g, s.b);
        return { l: lab[0], a: lab[1], lb: lab[2], r: s.r, g: s.g, b: s.b };
    });
    const result = [labSamples[Math.floor(Math.random() * labSamples.length)]];

    while (result.length < k) {
        let maxMinDist = -1;
        let bestCandidate = labSamples[0];

        for (const sample of labSamples) {
            let minDist = Infinity;
            for (const picked of result) {
                const distSq = (sample.l - picked.l) ** 2 + (sample.a - picked.a) ** 2 + (sample.lb - picked.lb) ** 2;
                if (distSq < minDist) minDist = distSq;
            }
            if (minDist > maxMinDist) {
                maxMinDist = minDist;
                bestCandidate = sample;
            }
        }
        result.push(bestCandidate);
    }
    return result.map(c => rgbToHex(c.r, c.g, c.b));
}

function extractContrasting(samples: { r: number, g: number, b: number }[], k: number): string[] {
    const lumSamples = samples.map(s => {
        const l = getLuminance(s.r, s.g, s.b) / 255.0; // 0 to 1
        return { r: s.r, g: s.g, b: s.b, lum: l };
    });

    let brightest = lumSamples[0];
    for (const s of lumSamples) if (s.lum > brightest.lum) brightest = s;
    const result = [brightest];

    while (result.length < k) {
        let maxMinContrast = -1;
        let bestCandidate = lumSamples[0];

        for (const sample of lumSamples) {
            let minContrast = Infinity;
            for (const picked of result) {
                const l1 = Math.max(sample.lum, picked.lum);
                const l2 = Math.min(sample.lum, picked.lum);
                const contrast = (l1 + 0.05) / (l2 + 0.05);
                if (contrast < minContrast) minContrast = contrast;
            }
            if (minContrast > maxMinContrast) {
                maxMinContrast = minContrast;
                bestCandidate = sample;
            }
        }
        result.push(bestCandidate);
    }
    return result.map(c => rgbToHex(c.r, c.g, c.b));
}


